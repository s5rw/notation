{"version":3,"file":"notation.js","mappings":"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","sources":["webpack://notation/webpack/universalModuleDefinition","webpack://notation/./src/core/notation.error.js","webpack://notation/./src/core/notation.glob.js","webpack://notation/./src/core/notation.js","webpack://notation/./src/utils.js","webpack://notation/webpack/bootstrap","webpack://notation/webpack/runtime/define property getters","webpack://notation/webpack/runtime/hasOwnProperty shorthand","webpack://notation/webpack/runtime/make namespace object","webpack://notation/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, () => {\nreturn ","/* eslint consistent-this:0, no-prototype-builtins:0 */\r\n\r\nconst setProto = Object.setPrototypeOf;\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @class\r\n *  @name Notation.Error\r\n */\r\nclass NotationError extends Error {\r\n\r\n    /**\r\n     *  Initializes a new `Notation.Error` instance.\r\n     *  @hideconstructor\r\n     *  @constructs Notation.Error\r\n     *  @param {String} message - The error message.\r\n     */\r\n    constructor(message = '') {\r\n        super(message);\r\n        setProto(this, NotationError.prototype);\r\n\r\n        Object.defineProperty(this, 'name', {\r\n            enumerable: false,\r\n            writable: false,\r\n            value: 'NotationError'\r\n        });\r\n\r\n        Object.defineProperty(this, 'message', {\r\n            enumerable: false,\r\n            writable: true,\r\n            value: message\r\n        });\r\n\r\n        /* istanbul ignore else */\r\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\r\n            Error.captureStackTrace(this, NotationError);\r\n        } else {\r\n            Object.defineProperty(this, 'stack', {\r\n                enumerable: false,\r\n                writable: false,\r\n                value: (new Error(message)).stack\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport { NotationError };\r\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\r\n\r\nimport { Notation } from './notation';\r\nimport { NotationError } from './notation.error';\r\nimport { utils } from '../utils';\r\n\r\n// http://www.linfo.org/wildcard.html\r\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\r\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\r\n\r\n// created test @ https://regex101.com/r/U08luj/2\r\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\r\n// created test @ https://regex101.com/r/mC8unE/3\r\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\r\nconst reVALIDATOR = new RegExp(\r\n    '^'\r\n    + '!?('                             // optional negation, only in the front\r\n    + '\\\\*'                             // wildcard star\r\n    + '|'                               // OR\r\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\r\n    + '|'                               // OR\r\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\r\n    + ')'                               // exactly once\r\n    + '('\r\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\r\n    + '|'                               // OR\r\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\r\n    + '|'                               // OR\r\n    + '\\\\.\\\\*'                          // dot, then wildcard star\r\n    + ')*'                              // (both) may repeat any number of times\r\n    + '$'\r\n    , 'i'\r\n);\r\n\r\nconst { re } = utils;\r\nconst ERR_INVALID = 'Invalid glob notation: ';\r\n\r\n/**\r\n *  `Notation.Glob` is a utility for validating, comparing and sorting\r\n *  dot-notation globs.\r\n *\r\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\r\n *  and negate the notation by prepending a bang `!`. A star will include all\r\n *  the properties at that level and a negated notation will be excluded.\r\n *  @name Glob\r\n *  @memberof Notation\r\n *  @class\r\n *\r\n *  @example\r\n *  // for the following object;\r\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\r\n *\r\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\r\n *  'billing.account.id' // represents value `1`\r\n *  '!billing.account.*' // represents value `{ name: 'John' }`\r\n *  'name' // represents `'John'`\r\n *  '*' // represents the whole object\r\n *\r\n *  @example\r\n *  var glob = new Notation.Glob('billing.account.*');\r\n *  glob.test('billing.account.id'); // true\r\n */\r\nclass Glob {\r\n\r\n    /**\r\n     *  Constructs a `Notation.Glob` object with the given glob string.\r\n     *  @constructs Notation.Glob\r\n     *  @param {String} glob - Notation string with globs.\r\n     *\r\n     *  @throws {NotationError} - If given notation glob is invalid.\r\n     */\r\n    constructor(glob) {\r\n        const ins = Glob._inspect(glob);\r\n        const notes = Glob.split(ins.absGlob);\r\n        this._ = {\r\n            ...ins,\r\n            notes,\r\n            // below props will be set at first getter call\r\n            parent: undefined, // don't set to null\r\n            regexp: undefined\r\n        };\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE PROPERTIES\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets the normalized glob notation string.\r\n     *  @name Notation.Glob#glob\r\n     *  @type {String}\r\n     */\r\n    get glob() {\r\n        return this._.glob;\r\n    }\r\n\r\n    /**\r\n     *  Gets the absolute glob notation without the negation prefix `!` and\r\n     *  redundant trailing wildcards.\r\n     *  @name Notation.Glob#absGlob\r\n     *  @type {String}\r\n     */\r\n    get absGlob() {\r\n        return this._.absGlob;\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether this glob is negated with a `!` prefix.\r\n     *  @name Notation.Glob#isNegated\r\n     *  @type {Boolean}\r\n     */\r\n    get isNegated() {\r\n        return this._.isNegated;\r\n    }\r\n\r\n    /**\r\n     *  Represents this glob in regular expressions.\r\n     *  Note that the negation prefix (`!`) is ignored, if any.\r\n     *  @name Notation.Glob#regexp\r\n     *  @type {RegExp}\r\n     */\r\n    get regexp() {\r\n        // setting on first call instead of in constructor, for performance\r\n        // optimization.\r\n        this._.regexp = this._.regexp || Glob.toRegExp(this.absGlob);\r\n        return this._.regexp;\r\n    }\r\n\r\n    /**\r\n     *  List of notes (levels) of this glob notation. Note that trailing,\r\n     *  redundant wildcards are removed from the original glob notation.\r\n     *  @name Notation.Glob#notes\r\n     *  @alias Notation.Glob#levels\r\n     *  @type {Array}\r\n     */\r\n    get notes() {\r\n        return this._.notes;\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation.Glob#notes`.\r\n     *  @private\r\n     *  @name Notation.Glob#notes\r\n     *  @alias Notation.Glob#levels\r\n     *  @type {Array}\r\n     */\r\n    get levels() {\r\n        return this._.notes;\r\n    }\r\n\r\n    /**\r\n     *  Gets the first note of this glob notation.\r\n     *  @name Notation.Glob#first\r\n     *  @type {String}\r\n     */\r\n    get first() {\r\n        return this.notes[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the last note of this glob notation.\r\n     *  @name Notation.Glob#last\r\n     *  @type {String}\r\n     */\r\n    get last() {\r\n        return this.notes[this.notes.length - 1];\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent notation (up to but excluding the last note) from the\r\n     *  glob notation string. Note that initially, trailing/redundant wildcards\r\n     *  are removed.\r\n     *  @name Notation.Glob#parent\r\n     *  @type {String}\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create;\r\n     *  glob('first.second.*').parent;   // \"first.second\"\r\n     *  glob('*.x.*').parent;            // \"*\" (\"*.x.*\" normalizes to \"*.x\")\r\n     *  glob('*').parent;                // null (no parent)\r\n     */\r\n    get parent() {\r\n        // setting on first call instead of in constructor, for performance\r\n        // optimization.\r\n        if (this._.parent === undefined) {\r\n            this._.parent = this.notes.length > 1\r\n                ? this.absGlob.slice(0, -this.last.length).replace(/\\.$/, '')\r\n                : null;\r\n        }\r\n        return this._.parent;\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE METHODS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Checks whether the given notation value matches the source notation\r\n     *  glob.\r\n     *  @name Notation.Glob#test\r\n     *  @function\r\n     *  @param {String} notation - The notation string to be tested. Cannot have\r\n     *  any globs.\r\n     *  @returns {Boolean} -\r\n     *  @throws {NotationError} - If given `notation` is not valid or contains\r\n     *  any globs.\r\n     *\r\n     *  @example\r\n     *  const glob = new Notation.Glob('!prop.*.name');\r\n     *  glob.test(\"prop.account.name\"); // true\r\n     */\r\n    test(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(`Invalid notation: '${notation}'`);\r\n        }\r\n        // return this.regexp.test(notation);\r\n        return Glob._covers(this, notation);\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether this glob notation can represent (or cover) the given\r\n     *  glob notation. Note that negation prefix is ignored, if any.\r\n     *  @name Notation.Glob#covers\r\n     *  @function\r\n     *\r\n     *  @param {String|Array|Glob} glob  Glob notation string, glob\r\n     *  notes array or a `Notation.Glob` instance.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create;\r\n     *  glob('*.y').covers('x.y')      // true\r\n     *  glob('x[*].y').covers('x[*]')  // false\r\n     */\r\n    covers(glob) {\r\n        return Glob._covers(this, glob);\r\n    }\r\n\r\n    /**\r\n     *  Gets the intersection of this and the given glob notations. When\r\n     *  restrictive, if any one of them is negated, the outcome is negated.\r\n     *  Otherwise, only if both of them are negated, the outcome is negated.\r\n     *  @name Notation.Glob#intersect\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Second glob to be used.\r\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\r\n     *  be negated when one of the globs is negated.\r\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create;\r\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\r\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\r\n     */\r\n    intersect(glob, restrictive = false) {\r\n        return Glob._intersect(this.glob, glob, restrictive);\r\n    }\r\n\r\n    // --------------------------------\r\n    // STATIC MEMBERS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `Notation.Glob` instance\r\n     *  with the given glob string.\r\n     *  @name Notation.Glob.create\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - The source notation glob.\r\n     *  @returns {Glob} -\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create(strGlob);\r\n     *  // equivalent to:\r\n     *  const glob = new Notation.Glob(strGlob);\r\n     */\r\n    static create(glob) {\r\n        return new Glob(glob);\r\n    }\r\n\r\n    // Created test at: https://regex101.com/r/tJ7yI9/4\r\n    /**\r\n     *  Validates the given notation glob.\r\n     *  @name Notation.Glob.isValid\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Notation glob to be validated.\r\n     *  @returns {Boolean} -\r\n     */\r\n    static isValid(glob) {\r\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether the given glob notation includes any valid wildcards\r\n     *  (`*`) or negation bang prefix (`!`).\r\n     *  @name Notation.Glob.hasMagic\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Glob notation to be checked.\r\n     *  @returns {Boolean} -\r\n     */\r\n    static hasMagic(glob) {\r\n        return Glob.isValid(glob) && (re.WILDCARDS.test(glob) || glob[0] === '!');\r\n    }\r\n\r\n    /**\r\n     *  Gets a regular expressions instance from the given glob notation.\r\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\r\n     *  @name Notation.Glob.toRegExp\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Glob notation to be converted.\r\n     *\r\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\r\n     *\r\n     *  @throws {NotationError} - If given notation glob is invalid.\r\n     */\r\n    static toRegExp(glob) {\r\n        if (!Glob.isValid(glob)) {\r\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\r\n        }\r\n\r\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\r\n        g = utils.pregQuote(g)\r\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\r\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\r\n            // `[\"x[*]y\"]`\r\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\r\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\r\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\r\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\r\n            .replace(/\\\\\\?/g, '.');\r\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\r\n        // it should either end ($) or continue with a dot or bracket. So for\r\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\r\n        // which will match both `company.name` and `company.address.street` but\r\n        // will not match `some.company.name`. Also `!password` will not match\r\n        // `!password_reset`.\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether first glob notation can represent (or cover) the\r\n     *  second.\r\n     *  @name Notation.Glob._covers\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {String|Object|Glob} globA  Source glob notation string\r\n     *  or inspection result object or `Notation.Glob` instance.\r\n     *  @param {String|Object|Glob} globB  Glob notation string or\r\n     *  inspection result object or `Notation.Glob` instance.\r\n     *  @param {Boolean} [match=false]  Check whether notes match instead of\r\n     *  `globA` covers `globB`.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  const { covers } = Notation.Glob;\r\n     *  covers('*.y', 'x.y')        // true\r\n     *  covers('x.y', '*.y')        // false\r\n     *  covers('x.y', '*.y', true)  // true\r\n     *  covers('x[*].y', 'x[*]')    // false\r\n     */\r\n    static _covers(globA, globB, match = false) {\r\n        const a = typeof globA === 'string'\r\n            ? new Glob(globA)\r\n            : globA; // assume (globA instanceof Notation.Glob || utils.type(globA) === 'object')\r\n\r\n        const b = typeof globB === 'string'\r\n            ? new Glob(globB)\r\n            : globB;\r\n\r\n        const notesA = a.notes || Glob.split(a.absGlob);\r\n        const notesB = b.notes || Glob.split(b.absGlob);\r\n\r\n        if (!match) {\r\n            // !x.*.* does not cover !x.* or x.* bec. !x.*.*  x.*  x\r\n            // x.*.* covers x.* bec. x.*.* = x.* = x\r\n            if (a.isNegated && notesA.length > notesB.length) return false;\r\n        }\r\n\r\n        let covers = true;\r\n        const fn = match ? _matchesNote : _coversNote;\r\n        for (let i = 0; i < notesA.length; i++) {\r\n            if (!fn(notesA[i], notesB[i])) {\r\n                covers = false;\r\n                break;\r\n            }\r\n        }\r\n        return covers;\r\n    }\r\n\r\n    /**\r\n     *  Gets the intersection notation of two glob notations. When restrictive,\r\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\r\n     *  if both of them are negated, the outcome is negated.\r\n     *  @name Notation.Glob._intersect\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {String} globA - First glob to be used.\r\n     *  @param {String} globB - Second glob to be used.\r\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\r\n     *  be negated when one of the globs is negated.\r\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\r\n     *  @example\r\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\r\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\r\n     */\r\n    static _intersect(globA, globB, restrictive = false) {\r\n        // const bang = restrictive\r\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\r\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\r\n\r\n        const notesA = Glob.split(globA, true);\r\n        const notesB = Glob.split(globB, true);\r\n\r\n        let bang;\r\n        if (restrictive) {\r\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\r\n        } else {\r\n            if (globA[0] === '!' && globB[0] === '!') {\r\n                bang = '!';\r\n            } else {\r\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\r\n                        || (notesB.length > notesA.length && globB[0] === '!'))\r\n                    ? '!'\r\n                    : '';\r\n            }\r\n        }\r\n\r\n        const len = Math.max(notesA.length, notesB.length);\r\n        let notesI = [];\r\n        let a, b;\r\n        //   x.*    *.y     x.y\r\n        // x.*.*    *.y     x.y.*\r\n        // x.*.z    *.y     x.y.z\r\n        //   x.y    *.b     (n/a)\r\n        //   x.y    a.*     (n/a)\r\n        for (let i = 0; i < len; i++) {\r\n            a = notesA[i];\r\n            b = notesB[i];\r\n            if (a === b) {\r\n                notesI.push(a);\r\n            } else if (a && re.WILDCARD.test(a)) {\r\n                if (!b) {\r\n                    notesI.push(a);\r\n                } else {\r\n                    notesI.push(b);\r\n                }\r\n            } else if (b && re.WILDCARD.test(b)) {\r\n                if (!a) {\r\n                    notesI.push(b);\r\n                } else {\r\n                    notesI.push(a);\r\n                }\r\n            } else if (a && !b) {\r\n                notesI.push(a);\r\n            } else if (!a && b) {\r\n                notesI.push(b);\r\n            } else { // if (a !== b) {\r\n                notesI = [];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *  Undocumented.\r\n     *  @name Notation.Glob._inspect\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {String} glob -\r\n     *  @returns {Object} -\r\n     */\r\n    static _inspect(glob) {\r\n        let g = glob.trim();\r\n        if (!Glob.isValid(g)) {\r\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\r\n        }\r\n        const isNegated = g[0] === '!';\r\n        // trailing wildcards are only redundant if not negated\r\n        if (!isNegated) g = utils.removeTrailingWildcards(g);\r\n        const absGlob = isNegated ? g.slice(1) : g;\r\n        return {\r\n            glob: g,\r\n            absGlob,\r\n            isNegated,\r\n            // e.g. [*] or [1] are array globs. [\"1\"] is not.\r\n            isArrayGlob: (/^\\[[^'\"]/).test(absGlob)\r\n        };\r\n    }\r\n\r\n    /**\r\n     *  Splits the given glob notation string into its notes (levels). Note that\r\n     *  this will exclude the `!` negation prefix, if it exists.\r\n     *  @name Notation.Glob.split\r\n     *  @function\r\n     *\r\n     *  @param {String} glob  Glob notation string to be splitted.\r\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\r\n     *  wildcards.\r\n     *  @returns {Array} - A string array of glob notes (levels).\r\n     *  @throws {NotationError} - If given glob notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.Glob.split('*.list[2].prop')  // ['*', 'list', '[2]', 'prop']\r\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\r\n     */\r\n    static split(glob, normalize = false) {\r\n        if (!Glob.isValid(glob)) {\r\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\r\n        }\r\n        const neg = glob[0] === '!';\r\n        // trailing wildcards are redundant only when not negated\r\n        const g = !neg && normalize ? utils.removeTrailingWildcards(glob) : glob;\r\n        return g.replace(/^!/, '').match(reMATCHER);\r\n    }\r\n\r\n    /**\r\n     *  Compares two given notation globs and returns an integer value as a\r\n     *  result. This is generally used to sort glob arrays. Loose globs (with\r\n     *  stars especially closer to beginning of the glob string) and globs\r\n     *  representing the parent/root of the compared property glob come first.\r\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. So\r\n     *  this works both for `*, store.address.street, !store.address` and `*,\r\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\r\n     *  `!prop.id` which represent the same property; the negated glob comes\r\n     *  last.\r\n     *  @name Notation.Glob.compare\r\n     *  @function\r\n     *\r\n     *  @param {String} globA - First notation glob to be compared.\r\n     *  @param {String} globB - Second notation glob to be compared.\r\n     *\r\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\r\n     *  comes first and `0` if equivalent priority.\r\n     *\r\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\r\n     *  notation.\r\n     *\r\n     *  @example\r\n     *  const { compare } = Notation.Glob;\r\n     *  compare('*', 'info.user')               // -1\r\n     *  compare('*', '[*]')                     // 0\r\n     *  compare('info.*.name', 'info.user')     // 1\r\n     */\r\n    static compare(globA, globB) {\r\n        // trivial case, both are exactly the same!\r\n        // or both are wildcard e.g. `*` or `[*]`\r\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\r\n\r\n        const a = new Glob(globA);\r\n        const b = new Glob(globB);\r\n\r\n        // Check depth (number of levels)\r\n        if (a.notes.length === b.notes.length) {\r\n            // check and compare if these are globs that represent items in the\r\n            // \"same\" array. if not, this will return 0.\r\n            const aIdxCompare = _compareArrayItemGlobs(a, b);\r\n            // we'll only continue comparing if 0 is returned\r\n            if (aIdxCompare !== 0) return aIdxCompare;\r\n\r\n            // count wildcards\r\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\r\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\r\n            if (wildCountA === wildCountB) {\r\n                // check for negation\r\n                if (!a.isNegated && b.isNegated) return -1;\r\n                if (a.isNegated && !b.isNegated) return 1;\r\n                // both are negated or neither are, return alphabetical\r\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\r\n            }\r\n            return wildCountA > wildCountB ? -1 : 1;\r\n        }\r\n\r\n        return a.notes.length < b.notes.length ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     *  Sorts the notation globs in the given array by their priorities. Loose\r\n     *  globs (with stars especially closer to beginning of the glob string);\r\n     *  globs representing the parent/root of the compared property glob come\r\n     *  first. Verbose/detailed/exact globs come last. (`* < *.y < x.y`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. For\r\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\r\n     *  the negated glob wins (comes last).\r\n     *  @name Notation.Glob.sort\r\n     *  @function\r\n     *\r\n     *  @param {Array} globList - The notation globs array to be sorted. The\r\n     *  passed array reference is modified.\r\n     *  @returns {Array} - Logically sorted globs array.\r\n     *\r\n     *  @example\r\n     *  Notation.Glob.sort(['!prop.*.name', 'prop.*', 'prop.id']) // ['prop.*', 'prop.id', '!prop.*.name'];\r\n     */\r\n    static sort(globList) {\r\n        return globList.sort(Glob.compare);\r\n    }\r\n\r\n    /**\r\n     *  Normalizes the given notation globs array by removing duplicate or\r\n     *  redundant items, eliminating extra verbosity (also with intersection\r\n     *  globs) and returns a priority-sorted globs array.\r\n     *\r\n     *  <ul>\r\n     *  <li>If any exact duplicates found, all except first is removed.\r\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\r\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\r\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\r\n     *  <li>If a glob is covered by another, it's removed.\r\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\r\n     *  <li>If a negated glob is covered by another glob, it's kept.\r\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\r\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\r\n     *  then we check for for intersection glob. If found, adds them to list;\r\n     *  removes the original negated.\r\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\r\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\r\n     *  Otherwise, it's kept.\r\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.normalize\r\n     *  @function\r\n     *\r\n     *  @param {Array} globList - Notation globs array to be normalized.\r\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\r\n     *  remove every match. Note that, regardless of this option, if any item has an\r\n     *  exact negated version; non-negated is always removed.\r\n     *  @returns {Array} -\r\n     *\r\n     *  @throws {NotationError} - If any item in globs list is invalid.\r\n     *\r\n     *  @example\r\n     *  const { normalize } = Notation.Glob;\r\n     *  normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']); // ['*', '!id', '!car.model']\r\n     *  normalize(['!*.id', 'user.*', 'company']); // ['company', 'user', '!company.id', '!user.id']\r\n     *  normalize(['*', 'car.model', '!car.*']); // [\"*\", \"!car.*\", \"car.model\"]\r\n     *  // restrictive normalize:\r\n     *  normalize(['*', 'car.model', '!car.*'], true); // [\"*\", \"!car.*\"]\r\n     */\r\n    static normalize(globList, restrictive = false) {\r\n        const { _inspect, _covers, _intersect } = Glob;\r\n\r\n        const original = utils.ensureArray(globList);\r\n        if (original.length === 0) return [];\r\n\r\n        const list = original\r\n            // prevent mutation\r\n            .concat()\r\n            // move negated globs to top so that we inspect non-negated globs\r\n            // against others first. when complete, we'll sort with our\r\n            // .compare() function.\r\n            .sort(restrictive ? _negFirstSort : _negLastSort)\r\n            // turning string array into inspect-obj array, so that we'll not\r\n            // run _inspect multiple times in the inner loop. this also\r\n            // pre-validates each glob.\r\n            .map(_inspect);\r\n\r\n        // early return if we have a single item\r\n        if (list.length === 1) {\r\n            const g = list[0];\r\n            // single negated item is redundant\r\n            if (g.isNegated) return [];\r\n            // return normalized\r\n            return [g.glob];\r\n        }\r\n\r\n        // flag to return an empty array (in restrictive mode), if true.\r\n        let negateAll = false;\r\n\r\n        // we'll push keepers in this array\r\n        let normalized = [];\r\n        // we'll need to remember excluded globs, so that we can move to next\r\n        // item early.\r\n        const ignored = {};\r\n\r\n        // storage to keep intersections.\r\n        // using an object to prevent duplicates.\r\n        let intersections = {};\r\n\r\n        function checkAddIntersection(gA, gB) {\r\n            const inter = _intersect(gA, gB, restrictive);\r\n            if (!inter) return;\r\n            // if the intersection result has an inverted version in the\r\n            // original list, don't add this.\r\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\r\n            // also if intersection result is in the current list, don't add it.\r\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\r\n            intersections[inter] = inter;\r\n        }\r\n\r\n        // iterate each glob by comparing it to remaining globs.\r\n        utils.eachRight(list, (a, indexA) => {\r\n\r\n            // if `strict` is enabled, return empty if a negate-all is found\r\n            // (which itself is also redundant if single): '!*' or '![*]'\r\n            if (re.NEGATE_ALL.test(a.glob)) {\r\n                negateAll = true;\r\n                if (restrictive) return false;\r\n            }\r\n\r\n            // flags\r\n            let duplicate = false;\r\n            let hasExactNeg = false;\r\n            // flags for negated\r\n            let negCoversPos = false;\r\n            let negCoveredByPos = false;\r\n            let negCoveredByNeg = false;\r\n            // flags for non-negated (positive)\r\n            let posCoversPos = false;\r\n            let posCoveredByNeg = false;\r\n            let posCoveredByPos = false;\r\n\r\n            utils.eachRight(list, (b, indexB) => {\r\n                // don't inspect glob with itself\r\n                if (indexA === indexB) return; // move to next\r\n                // console.log(indexA, a.glob, 'vs', b.glob);\r\n\r\n                // e.g. ['x.y.z', '[1].x', 'c']  impossible! the tested source\r\n                // object cannot be both an array and an object.\r\n                if (a.isArrayGlob !== b.isArrayGlob) {\r\n                    throw new NotationError(`Integrity failed. Cannot have both object and array notations for root level: ${JSON.stringify(original)}`);\r\n                }\r\n\r\n                // remove if duplicate\r\n                if (a.glob === b.glob) {\r\n                    list.splice(indexA, 1);\r\n                    duplicate = true;\r\n                    return false; // break out\r\n                }\r\n\r\n                // remove if positive has an exact negated (negated wins when\r\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\r\n                if (!a.isNegated && _isReverseOf(a, b)) {\r\n                    // list.splice(indexA, 1);\r\n                    ignored[a.glob] = true;\r\n                    hasExactNeg = true;\r\n                    return false; // break out\r\n                }\r\n\r\n                // if already excluded b, go on to next\r\n                if (ignored[b.glob]) return; // next\r\n\r\n                const coversB = _covers(a, b);\r\n                const coveredByB = coversB ? false : _covers(b, a);\r\n                if (a.isNegated) {\r\n                    if (b.isNegated) {\r\n                        // if negated (a) covered by any other negated (b); remove (a)!\r\n                        if (coveredByB) {\r\n                            negCoveredByNeg = true;\r\n                            // list.splice(indexA, 1);\r\n                            ignored[a.glob] = true;\r\n                            return false; // break out\r\n                        }\r\n                    } else {\r\n                        /* istanbul ignore if */\r\n                        if (coversB) negCoversPos = true;\r\n                        if (coveredByB) negCoveredByPos = true;\r\n                        // try intersection if none covers the other and only\r\n                        // one of them is negated.\r\n                        if (!coversB && !coveredByB) {\r\n                            checkAddIntersection(a.glob, b.glob);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (b.isNegated) {\r\n                        // if positive (a) covered by any negated (b); remove (a)!\r\n                        if (coveredByB) {\r\n                            posCoveredByNeg = true;\r\n                            if (restrictive) {\r\n                                // list.splice(indexA, 1);\r\n                                ignored[a.glob] = true;\r\n                                return false; // break out\r\n                            }\r\n                            return; // next\r\n                        }\r\n                        // try intersection if none covers the other and only\r\n                        // one of them is negated.\r\n                        if (!coversB && !coveredByB) {\r\n                            checkAddIntersection(a.glob, b.glob);\r\n                        }\r\n                    } else {\r\n                        if (coversB) posCoversPos = coversB;\r\n                        // if positive (a) covered by any other positive (b); remove (a)!\r\n                        if (coveredByB) {\r\n                            posCoveredByPos = true;\r\n                            if (restrictive) {\r\n                                // list.splice(indexA, 1);\r\n                                return false; // break out\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\r\n            const keepNeg = restrictive\r\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\r\n                : negCoveredByPos && negCoveredByNeg === false;\r\n            const keepPos = restrictive\r\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\r\n                : posCoveredByNeg || posCoveredByPos === false;\r\n            const keep = duplicate === false\r\n                && hasExactNeg === false\r\n                && (a.isNegated ? keepNeg : keepPos);\r\n\r\n            if (keep) {\r\n                normalized.push(a.glob);\r\n            } else {\r\n                // this is excluded from final (normalized) list, so mark as\r\n                // ignored (don't remove from \"list\" for now)\r\n                ignored[a.glob] = true;\r\n            }\r\n        });\r\n\r\n        if (restrictive && negateAll) return [];\r\n\r\n        intersections = Object.keys(intersections);\r\n        if (intersections.length > 0) {\r\n            // merge normalized list with intersections if any\r\n            normalized = normalized.concat(intersections);\r\n            // we have new (intersection) items, so re-normalize\r\n            return Glob.normalize(normalized, restrictive);\r\n        }\r\n\r\n        return Glob.sort(normalized);\r\n    }\r\n\r\n    /**\r\n     *  Undocumented. See `.union()`\r\n     *  @name Notation.Glob._compareUnion\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {Array} globsListA -\r\n     *  @param {Array} globsListB -\r\n     *  @param {Boolean} restrictive -\r\n     *  @param {Array} union -\r\n     *  @returns {Array} -\r\n     */\r\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\r\n        const { _covers } = Glob;\r\n\r\n        const { _inspect, _intersect } = Glob;\r\n\r\n        utils.eachRight(globsListA, globA => {\r\n            if (union.indexOf(globA) >= 0) return; // next\r\n\r\n            const a = _inspect(globA);\r\n\r\n            // if wildcard only, add...\r\n            if (re.WILDCARD.test(a.absGlob)) {\r\n                union.push(a.glob); // push normalized glob\r\n                return; // next\r\n            }\r\n\r\n            let notCovered = false;\r\n            let hasExact = false;\r\n            let negCoversNeg = false;\r\n            let posCoversNeg = false;\r\n            let posCoversPos = false;\r\n            let negCoversPos = false;\r\n\r\n            const intersections = [];\r\n\r\n            utils.eachRight(globsListB, globB => {\r\n\r\n                // keep if has exact in the other\r\n                if (globA === globB) hasExact = true;\r\n\r\n                const b = _inspect(globB);\r\n\r\n                // keep negated if:\r\n                //    1) any negated covers it\r\n                //    2) no positive covers it\r\n                // keep positive if:\r\n                //    1) no positive covers it OR any negated covers it\r\n\r\n                notCovered = !_covers(b, a);\r\n                if (notCovered) {\r\n                    if (a.isNegated && b.isNegated) {\r\n                        const inter = _intersect(a.glob, b.glob, restrictive);\r\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\r\n                    }\r\n                    return; // next\r\n                }\r\n\r\n                if (a.isNegated) {\r\n                    if (b.isNegated) {\r\n                        negCoversNeg = !hasExact;\r\n                    } else {\r\n                        posCoversNeg = true; // set flag\r\n                    }\r\n                } else {\r\n                    if (!b.isNegated) {\r\n                        posCoversPos = !hasExact;\r\n                    } else {\r\n                        negCoversPos = true; // set flag\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n\r\n            const keep = a.isNegated\r\n                ? (!posCoversNeg || negCoversNeg)\r\n                : (!posCoversPos || negCoversPos);\r\n\r\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\r\n                union.push(a.glob); // push normalized glob\r\n                return;\r\n            }\r\n\r\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\r\n                union = union.concat(intersections);\r\n            }\r\n\r\n        });\r\n\r\n        return union;\r\n    }\r\n\r\n    /**\r\n     *  Gets the union from the given couple of glob arrays and returns a new\r\n     *  array of globs.\r\n     *  <ul>\r\n     *  <li>If the exact same element is found in both\r\n     *  arrays, one of them is removed to prevent duplicates.\r\n     *  <br />example: `['!id', 'name']  ['!id']` unites to `['!id', 'name']`</li>\r\n     *  <li>If any non-negated item is covered by a glob in the same\r\n     *  or other array, the redundant item is removed.\r\n     *  <br />example: `['*', 'name']  ['email']` unites to `['*']`</li>\r\n     *  <li>If one of the arrays contains a negated equivalent of an\r\n     *  item in the other array, the negated item is removed.\r\n     *  <br />example: `['!id']  ['id']` unites to `['id']`</li>\r\n     *  <li>If any item covers/matches a negated item in the other array,\r\n     *  the negated item is removed.\r\n     *  <br />example #1: `['!user.id']  ['user.*']` unites to `['user']`\r\n     *  <br />example #2: `['*']  ['!password']` unites to `['*']`\r\n     *  </li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.union\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsA - First array of glob strings.\r\n     *  @param {Array} globsB - Second array of glob strings.\r\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\r\n     *  the lists, strictly remove every match in themselves (not the cross\r\n     *  list). This option is used when pre-normalizing each glob list and\r\n     *  normalizing the final union list.\r\n     *\r\n     *  @returns {Array} -\r\n     *\r\n     *  @example\r\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\r\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\r\n     *  const { union } = Notation.Glob;\r\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\r\n     */\r\n    static union(globsA, globsB, restrictive) {\r\n        const { normalize, _compareUnion } = Glob;\r\n\r\n        const listA = normalize(globsA, restrictive);\r\n        const listB = normalize(globsB, restrictive);\r\n\r\n        if (listA.length === 0) return listB;\r\n        if (listB.length === 0) return listA;\r\n\r\n        // TODO: below should be optimized\r\n        let union = _compareUnion(listA, listB, restrictive);\r\n        union = _compareUnion(listB, listA, restrictive, union);\r\n        return normalize(union, restrictive);\r\n    }\r\n\r\n}\r\n\r\n// --------------------------------\r\n// HELPERS\r\n// --------------------------------\r\n\r\n// used by static _covers\r\nfunction _coversNote(a, b) {\r\n    if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\r\n    const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\r\n    // obj-wildcard a will cover b if not array\r\n    if (a === '*') return !bIsArr;\r\n    // arr-wildcard a will cover b if array\r\n    if (a === '[*]') return bIsArr;\r\n    // seems, a is not wildcard so,\r\n    // if b is wildcard (obj or arr) won't be covered\r\n    if (re.WILDCARD.test(b)) return false;\r\n    // normalize both and check for equality\r\n    // e.g. x.y and x['y'] are the same\r\n    return utils.normalizeNote(a) === utils.normalizeNote(b);\r\n}\r\n// function _coversNote(a, b) {\r\n//     if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\r\n//     a = utils.normalizeNote(a, true);\r\n//     b = utils.normalizeNote(b, true);\r\n//     if (a === b) return true;\r\n//     const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\r\n//     return (a === '*' && !bIsArr) || (a === '[*]' && bIsArr);\r\n// }\r\n// used by static _covers\r\nfunction _matchesNote(a, b) {\r\n    if (!a || !b) return true; // glob e.g.: [2][1] matches [2] and vice-versa.\r\n    return _coversNote(a, b) || _coversNote(b, a);\r\n}\r\n\r\n// used by _compareArrayItemGlobs() for getting a numeric index from array note.\r\n// we'll use these indexes to sort higher to lower, as removing order; to\r\n// prevent shifted indexes.\r\nfunction _idxVal(note) {\r\n    // we return -1 for wildcard bec. we need it to come last\r\n\r\n    // below will never execute when called from _compareArrayItemGlobs\r\n    /* istanbul ignore next */\r\n    // if (note === '[*]') return -1;\r\n\r\n    // e.g. '[2]'  2\r\n    return parseInt(note.replace(/[[\\]]/, ''), 10);\r\n}\r\n\r\nfunction _compArrIdx(lastA, lastB) {\r\n    const iA = _idxVal(lastA);\r\n    const iB = _idxVal(lastB);\r\n\r\n    // below will never execute when called from _compareArrayItemGlobs\r\n    /* istanbul ignore next */\r\n    // if (iA === iB) return 0;\r\n\r\n    return iA > iB ? -1 : 1;\r\n}\r\n\r\n// when we remove items from an array (via e.g. filtering), we first need to\r\n// remove the item with the greater index so indexes of other items (that are to\r\n// be removed from the same array) do not shift. so below is for comparing 2\r\n// globs if they represent 2 items from the same array.\r\n\r\n// example items from same array: ![*][2] ![0][*] ![0][1] ![0][3]\r\n// should be sorted as ![0][3] ![*][2] ![0][1] ![0][*]\r\nfunction _compareArrayItemGlobs(a, b) {\r\n    const reANote = re.ARRAY_GLOB_NOTE;\r\n    // both should be negated\r\n    if (!a.isNegated\r\n            || !b.isNegated\r\n            // should be same length (since we're comparing for items in same\r\n            // array)\r\n            || a.notes.length !== b.notes.length\r\n            // last notes should be array brackets\r\n            || !reANote.test(a.last)\r\n            || !reANote.test(b.last)\r\n            // last notes should be different to compare\r\n            || a.last === b.last\r\n    ) return 0;\r\n\r\n    // negated !..[*] should come last\r\n    if (a.last === '[*]') return 1; // b is first\r\n    if (b.last === '[*]') return -1; // a is first\r\n\r\n    if (a.parent && b.parent) {\r\n        const { _covers } = Glob;\r\n        if (_covers(a.parent, b.parent, true)) {\r\n            return _compArrIdx(a.last, b.last);\r\n        }\r\n        return 0;\r\n    }\r\n    return _compArrIdx(a.last, b.last);\r\n}\r\n\r\n// x vs !x.*.*       false\r\n// x vs !x[*]        true\r\n// x[*] vs !x        true\r\n// x[*] vs !x[*]     false\r\n// x.* vs !x.*       false\r\nfunction _isReverseOf(a, b) {\r\n    return a.isNegated !== b.isNegated\r\n        && a.absGlob === b.absGlob;\r\n}\r\n\r\nfunction _invert(glob) {\r\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\r\n}\r\n\r\nconst _rx = /^\\s*!/;\r\nfunction _negFirstSort(a, b) {\r\n    const negA = _rx.test(a);\r\n    const negB = _rx.test(b);\r\n    if (negA && negB) return a.length >= b.length ? 1 : -1;\r\n    if (negA) return -1;\r\n    if (negB) return 1;\r\n    return 0;\r\n}\r\nfunction _negLastSort(a, b) {\r\n    const negA = _rx.test(a);\r\n    const negB = _rx.test(b);\r\n    if (negA && negB) return a.length >= b.length ? 1 : -1;\r\n    if (negA) return 1;\r\n    if (negB) return -1;\r\n    return 0;\r\n}\r\n\r\n// --------------------------------\r\n// EXPORT\r\n// --------------------------------\r\n\r\nexport { Glob };\r\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0, max-len:0 */\r\n\r\nimport { Glob } from './notation.glob';\r\nimport { NotationError } from './notation.error';\r\nimport { utils } from '../utils';\r\n\r\nconst ERR = {\r\n    SOURCE: 'Invalid source. Expected a data object or array.',\r\n    DEST: 'Invalid destination. Expected a data object or array.',\r\n    NOTATION: 'Invalid notation: ',\r\n    NOTA_OBJ: 'Invalid notations object. ',\r\n    NO_INDEX: 'Implied index does not exist: ',\r\n    NO_PROP: 'Implied property does not exist: '\r\n};\r\n\r\n// created test @ https://regex101.com/r/vLE16M/2\r\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\r\n// created test @ https://regex101.com/r/fL3PJt/1/\r\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\r\nconst reVALIDATOR = new RegExp(\r\n    '^('\r\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\r\n    + '|'                           // OR\r\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\r\n    + ')'                           // exactly once\r\n    + '('\r\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\r\n    + '|'                           // OR\r\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\r\n    + ')*'                          // (both) may repeat any number of times\r\n    + '$'\r\n    , 'i'\r\n);\r\n\r\nconst DEFAULT_OPTS = Object.freeze({\r\n    strict: false,\r\n    preserveIndices: false\r\n});\r\n\r\n/**\r\n *  Notation.js for Node and Browser.\r\n *\r\n *  Like in most programming languages, JavaScript makes use of dot-notation to\r\n *  access the value of a member of an object (or class). `Notation` class\r\n *  provides various methods for modifying / processing the contents of the\r\n *  given object; by parsing object notation strings or globs.\r\n *\r\n *  Note that this class will only deal with enumerable properties of the source\r\n *  object; so it should be used to manipulate data objects. It will not deal\r\n *  with preserving the prototype-chain of the given object.\r\n *\r\n *  @author   Onur Yldrm <onur@cutepilot.com>\r\n *  @license  MIT\r\n */\r\nclass Notation {\r\n\r\n    /**\r\n     *  Initializes a new instance of `Notation`.\r\n     *\r\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\r\n     *  notated. Can either be an array or object. If omitted, defaults to an\r\n     *  empty object.\r\n     *  @param {Object} [options] - Notation options.\r\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\r\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\r\n     *      methods); or notation path exists but overwriting is disabled (i.e.\r\n     *      `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\r\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\r\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\r\n     *      it will always throw on invalid notation syntax or other crucial failures.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = new Notation(obj);\r\n     *  notation.get('car.model')   //  \"Charger\"\r\n     *  notation.remove('car.model').set('car.color', 'red').value\r\n     *  //  { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\r\n     */\r\n    constructor(source, options) {\r\n        if (arguments.length === 0) {\r\n            this._source = {};\r\n        } else if (!utils.isCollection(source)) {\r\n            throw new NotationError(ERR.SOURCE);\r\n        } else {\r\n            this._source = source;\r\n        }\r\n\r\n        this._isArray = utils.type(this._source) === 'array';\r\n        this.options = options;\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE PROPERTIES\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets or sets notation options.\r\n     *  @type {Object}\r\n     */\r\n    get options() {\r\n        return this._options;\r\n    }\r\n\r\n    set options(value) {\r\n        this._options = {\r\n            ...DEFAULT_OPTS,\r\n            ...(this._options || {}),\r\n            ...(value || {})\r\n        };\r\n    }\r\n\r\n    /**\r\n     *  Gets the value of the source object.\r\n     *  @type {Object|Array}\r\n     *\r\n     *  @example\r\n     *  const person = { name: \"Onur\" };\r\n     *  const me = Notation.create(person)\r\n     *      .set(\"age\", 36)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .value;\r\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\r\n     *  console.log(person === me); // true\r\n     */\r\n    get value() {\r\n        return this._source;\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE METHODS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Recursively iterates through each key of the source object and invokes\r\n     *  the given callback function with parameters, on each non-object value.\r\n     *\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each on each non-object value. To break out of the loop, return `false`\r\n     *  from within the callback.\r\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj).each(function (notation, key, value, object) {\r\n     *      console.log(notation, value);\r\n     *  });\r\n     *  // \"car.brand\"  \"Dodge\"\r\n     *  // \"car.model\"  \"Charger\"\r\n     *  // \"car.year\"  1970\r\n     */\r\n    each(callback) {\r\n        _each(this._source, callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note of the given notation string by evaluating\r\n     *  it on the source object.\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within\r\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\r\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\r\n     *      });\r\n     */\r\n    eachValue(notation, callback) {\r\n        let level = this._source;\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\r\n            if (callback(level, levelNotation, note, index, list) === false) return false;\r\n\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Gets the list of notations from the source object (keys).\r\n     *\r\n     *  @returns {Array} - An array of notation strings.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notations = Notation.create(obj).getNotations();\r\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\r\n     */\r\n    getNotations() {\r\n        const list = [];\r\n        this.each(notation => {\r\n            list.push(notation);\r\n        });\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     *  Deeply clones the source object. This is also useful if you want to\r\n     *  prevent mutating the original source object.\r\n     *\r\n     *  <blockquote>\r\n     *  Note that `Notation` expects a data object (or array) with enumerable\r\n     *  properties. In addition to plain objects and arrays; supported cloneable\r\n     *  property/value types are primitives (such as `String`, `Number`,\r\n     *  `Boolean`, `Symbol`, `null` and `undefined`) and built-in types (such as\r\n     *  `Date` and `RegExp`).\r\n     *\r\n     *  Enumerable properties with types other than these (such as methods,\r\n     *  special objects, custom class instances, etc) will be copied by reference.\r\n     *  Non-enumerable properties will not be cloned.\r\n     *\r\n     *  If you still need full clone support, you can use a library like lodash.\r\n     *  e.g. `Notation.create(_.cloneDeep(source))`\r\n     *  </blockquote>\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const mutated = Notation.create(source1).set('newProp', true).value;\r\n     *  console.log(source1.newProp); //  true\r\n     *\r\n     *  const cloned = Notation.create(source2).clone().set('newProp', true).value;\r\n     *  console.log('newProp' in source2); //  false\r\n     *  console.log(cloned.newProp); //  true\r\n     */\r\n    clone() {\r\n        this._source = utils.cloneDeep(this._source);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Flattens the source object to a single-level object with notated keys.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  console.log(Notation.create(obj).flatten().value);\r\n     *  // {\r\n     *  //     \"car.brand\": \"Dodge\",\r\n     *  //     \"car.model\": \"Charger\",\r\n     *  //     \"car.year\": 1970\r\n     *  // }\r\n     */\r\n    flatten() {\r\n        const o = {};\r\n        this.each((notation, key, value) => {\r\n            o[notation] = value;\r\n        });\r\n        this._source = o;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Aggregates notated keys of a (single-level) object, and nests them under\r\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\r\n     *  method. This might be useful when expanding a flat object fetched from\r\n     *  a database.\r\n     *  @alias Notation#aggregate\r\n     *  @chainable\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n     *  const expanded = Notation.create(obj).expand().value;\r\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     */\r\n    expand() {\r\n        this._source = Notation.create({}).merge(this._source).value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#expand`\r\n     *  @private\r\n     *  @returns {Notation} -\r\n     */\r\n    aggregate() {\r\n        return this.expand();\r\n    }\r\n\r\n    /**\r\n     *  Inspects the given notation on the source object by checking\r\n     *  if the source object actually has the notated property;\r\n     *  and getting its value if exists.\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.year\");\r\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\r\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.color\");\r\n     *  // { has: false }\r\n     *  Notation.create({ car: { color: undefined } }).inspectGet(\"car.color\");\r\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\r\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspectGet(\"car.brands[1]\");\r\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\r\n     */\r\n    inspectGet(notation) {\r\n        let level = this._source;\r\n        let result = { has: false, value: undefined };\r\n        let parent;\r\n        Notation.eachNote(notation, (levelNotation, note, index) => {\r\n            const lastNoteNormalized = utils.normalizeNote(note);\r\n            if (utils.hasOwn(level, lastNoteNormalized)) {\r\n                level = level[lastNoteNormalized];\r\n                parent = level;\r\n                result = {\r\n                    notation,\r\n                    has: true,\r\n                    value: level,\r\n                    type: utils.type(level),\r\n                    level: index + 1,\r\n                    lastNote: note,\r\n                    lastNoteNormalized\r\n                };\r\n            } else {\r\n                // level = undefined;\r\n                result = {\r\n                    notation,\r\n                    has: false,\r\n                    type: 'undefined',\r\n                    level: index + 1,\r\n                    lastNote: note,\r\n                    lastNoteNormalized\r\n                };\r\n                return false; // break out\r\n            }\r\n        });\r\n\r\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\r\n        result.parentIsArray = utils.type(parent) === 'array';\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Notation inspection result object.\r\n     *  @typedef Notation~InspectResult\r\n     *  @type Object\r\n     *  @property {String} notation - Notation that is inspected.\r\n     *  @property {Boolean} has - Indicates whether the source object has the\r\n     *  given notation as a (leveled) enumerable property. If the property\r\n     *  exists but has a value of `undefined`, this will still return `true`.\r\n     *  @property {*} value - The value of the notated property. If the source\r\n     *  object does not have the notation, the value will be `undefined`.\r\n     *  @property {String} type - The type of the notated property. If the source\r\n     *  object does not have the notation, the type will be `\"undefined\"`.\r\n     *  @property {String} lastNote - Last note of the notation, if actually\r\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\r\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\r\n     *  of the last note of the notation, if actually exists. For example, last\r\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\r\n     *  indicates an array index.\r\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\r\n     *  notation path is an array.\r\n     */\r\n\r\n    /**\r\n     *  Inspects and removes the given notation from the source object by\r\n     *  checking if the source object actually has the notated property; and\r\n     *  getting its value if exists, before removing the property.\r\n     *\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  const obj = { name: \"John\", car: { year: 1970 } };\r\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\r\n     *  // result  { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\r\n     *  // obj  { name: \"John\", car: {} }\r\n     *\r\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\r\n     *  // result  { notation: \"car.color\", has: false }\r\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\r\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\r\n     *\r\n     *  const obj = { car: { colors: [\"black\", \"white\"] } };\r\n     *  const result = Notation.create().inspectRemove(\"car.colors[0]\");\r\n     *  // result  { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\r\n     *  // obj  { car: { colors: [(empty), \"white\"] } }\r\n     */\r\n    inspectRemove(notation) {\r\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\r\n        const parentNotation = Notation.parent(notation);\r\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\r\n        const parentIsArray = utils.type(parent) === 'array';\r\n        const notes = Notation.split(notation);\r\n        const lastNote = notes[notes.length - 1];\r\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\r\n\r\n        let result, value;\r\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\r\n            value = parent[lastNoteNormalized];\r\n            result = {\r\n                notation,\r\n                has: true,\r\n                value,\r\n                type: utils.type(value),\r\n                level: notes.length,\r\n                lastNote,\r\n                lastNoteNormalized,\r\n                parentIsArray\r\n            };\r\n\r\n            // if `preserveIndices` is enabled and this is an array, we'll\r\n            // splice the item out. otherwise, we'll use `delete` syntax to\r\n            // empty the item.\r\n            if (!this.options.preserveIndices && parentIsArray) {\r\n                parent.splice(lastNoteNormalized, 1);\r\n            } else {\r\n                delete parent[lastNoteNormalized];\r\n            }\r\n        } else {\r\n            result = {\r\n                notation,\r\n                has: false,\r\n                type: 'undefined',\r\n                level: notes.length,\r\n                lastNote,\r\n                lastNoteNormalized,\r\n                parentIsArray\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) enumerable property. If the property exists\r\n     *  but has a value of `undefined`, this will still return `true`.\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\r\n     *  Notation.create({}).has(\"car.color\"); // false\r\n     */\r\n    has(notation) {\r\n        return this.inspectGet(notation).has;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) defined enumerable property. If the property\r\n     *  exists but has a value of `undefined`, this will return `false`.\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\r\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\r\n     */\r\n    hasDefined(notation) {\r\n        return this.inspectGet(notation).value !== undefined;\r\n    }\r\n\r\n    /**\r\n     *  Gets the value of the corresponding property at the given notation.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {String} [defaultValue] - The default value to be returned if the\r\n     *  property is not found or enumerable.\r\n     *\r\n     *  @returns {*} - The value of the notated property.\r\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\r\n     *  is not set and notation does not exist.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\r\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\r\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\r\n     *\r\n     *  @example <caption>get value when strict option is enabled</caption>\r\n     *  // strict option defaults to false\r\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\r\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\r\n     *  // below will throw bec. strict = true, car.model does not exist\r\n     *  // and no default value is given.\r\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\r\n     */\r\n    get(notation, defaultValue) {\r\n        const result = this.inspectGet(notation);\r\n        // if strict and no default value is set, check if implied index or prop\r\n        // exists\r\n        if (this.options.strict && arguments.length < 2 && !result.has) {\r\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\r\n            throw new NotationError(msg + `'${notation}'`);\r\n        }\r\n        return result.has ? result.value : defaultValue;\r\n    }\r\n\r\n    /**\r\n     *  Sets the value of the corresponding property at the given notation. If\r\n     *  the property does not exist, it will be created and nested at the\r\n     *  calculated level. If it exists; its value will be overwritten by\r\n     *  default.\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {*} value - The value to be set for the notated property.\r\n     *  @param {String|Boolean} [mode=\"overwrite\"] - Write mode. By default,\r\n     *  this is set to `\"overwrite\"` which sets the value by overwriting the\r\n     *  target object property or array item at index. To insert an array item\r\n     *  (by shifting the index, instead of overwriting); set to `\"insert\"`. To\r\n     *  prevent overwriting the value if exists, explicitly set to `false`.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\r\n     *  option is set to `false` and attempted to overwrite an existing value.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .set(\"car.year\", 1965, false)\r\n     *      .set(\"car.color\", \"red\")\r\n     *      .set(\"boat\", \"none\");\r\n     *  console.log(obj);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    set(notation, value, mode = 'overwrite') {\r\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\r\n        if (mode === true) mode = 'overwrite';\r\n        let level = this._source;\r\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote, type;\r\n        const insertErrMsg = 'Cannot set value by inserting at index, on an object';\r\n\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            currentIsLast = index === list.length - 1;\r\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\r\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\r\n            type = utils.type(level);\r\n\r\n            if (type === 'array' && typeof nCurrentNote !== 'number') {\r\n                const parent = Notation.parent(levelNotation) || 'source';\r\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\r\n            }\r\n\r\n            // check if the property is at this level\r\n            if (utils.hasOwn(level, nCurrentNote, type)) {\r\n                // check if we're at the last level\r\n                if (currentIsLast) {\r\n                    // if mode is \"overwrite\", assign the value.\r\n                    if (mode === 'overwrite') {\r\n                        level[nCurrentNote] = value;\r\n                    } else if (mode === 'insert') {\r\n                        if (type === 'array') {\r\n                            level.splice(nCurrentNote, 0, value);\r\n                        } else {\r\n                            throw new NotationError(insertErrMsg);\r\n                        }\r\n                    }\r\n                    // otherwise, will not overwrite\r\n                } else {\r\n                    // if not last level; just re-reference the current level.\r\n                    level = level[nCurrentNote];\r\n                }\r\n            } else {\r\n                if (currentIsLast && type !== 'array' && mode === 'insert') {\r\n                    throw new NotationError(insertErrMsg);\r\n                }\r\n\r\n                // if next normalized note is a number, it indicates that the\r\n                // current note is actually an array.\r\n                nextIsArrayNote = typeof nNextNote === 'number';\r\n\r\n                // we don't have this property at this level so; if this is the\r\n                // last level, we set the value if not, we set an empty\r\n                // collection for the next level\r\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\r\n                level = level[nCurrentNote];\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Just like the `.set()` method but instead of a single notation\r\n     *  string, an object of notations and values can be passed.\r\n     *  Sets the value of each corresponding property at the given\r\n     *  notation. If a property does not exist, it will be created\r\n     *  and nested at the calculated level. If it exists; its value\r\n     *  will be overwritten by default.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} notationsObject - The notations object to be processed.\r\n     *  This can either be a regular object with non-dotted keys\r\n     *  (which will be merged to the first/root level of the source object);\r\n     *  or a flattened object with notated (dotted) keys.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\r\n     *  exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj).merge({\r\n     *      \"car.brand\": \"Ford\",\r\n     *      \"car.model\": \"Mustang\",\r\n     *      \"car.year\": 1965,\r\n     *      \"car.color\": \"red\",\r\n     *      \"boat\": \"none\"\r\n     *  });\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    merge(notationsObject, overwrite = true) {\r\n        if (utils.type(notationsObject) !== 'object') {\r\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\r\n        }\r\n        let value;\r\n        utils.each(Object.keys(notationsObject), notation => {\r\n            value = notationsObject[notation];\r\n            this.set(notation, value, overwrite);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the properties by the given list of notations from the source\r\n     *  object and returns a new object with the removed properties.\r\n     *  Opposite of `merge()` method.\r\n     *\r\n     *  @param {Array} notations - The notations array to be processed.\r\n     *\r\n     *  @returns {Object} - An object with the removed properties.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\r\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\r\n     *  console.log(separated);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\r\n     *  console.log(obj);\r\n     *  // { car: { year: 1970 } };\r\n     */\r\n    separate(notations) {\r\n        if (utils.type(notations) !== 'array') {\r\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\r\n        }\r\n        const o = new Notation({});\r\n        utils.each(notations, notation => {\r\n            const result = this.inspectRemove(notation);\r\n            o.set(notation, result.value);\r\n        });\r\n        this._source = o._source;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Deep clones the source object while filtering its properties by the\r\n     *  given <b>glob</b> notations. Includes all matched properties and removes\r\n     *  the rest.\r\n     *\r\n     *  The difference between regular notations and glob-notations is that;\r\n     *  with the latter, you can use wildcard stars (*) and negate the notation\r\n     *  by prepending a bang (!). A negated notation will be excluded.\r\n     *\r\n     *  Order of the globs does not matter; they will be logically sorted. Loose\r\n     *  globs will be processed first and verbose globs or normal notations will\r\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\r\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\r\n     *\r\n     *  Passing no parameters or passing a glob of `\"!*\"` or `[\"!*\"]` will empty\r\n     *  the source object. See `Notation.Glob` class for more information.\r\n     *  @chainable\r\n     *\r\n     *  @param {Array|String} globList - Glob notation list to be processed.\r\n     *  @param {Object} [options] - Filter options.\r\n     *  @param {Boolean} [options.restrictive=false] - Whether negated items\r\n     *  strictly remove every match. Note that, regardless of this option, if\r\n     *  any item has an exact negated version; non-negated is always removed.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self). To get the\r\n     *  filtered value, call `.value` property on the instance.\r\n     *\r\n     *  @example\r\n     *  const car = { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } };\r\n     *  const n = Notation.create(car);\r\n     *\r\n     *  console.log(n.filter([ \"*\", \"!model.year\" ]).value);  // { brand: \"Ford\", model: { name: \"Mustang\" } }\r\n     *  console.log(n.filter(\"model.name\").value);            // { model: { name: \"Mustang\" } }\r\n     *  console.log(car);                                     // { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } }\r\n     *  console.log(n.filter().value);                        // {} //  equivalent to n.filter(\"\") or n.filter(\"!*\")\r\n     */\r\n    filter(globList, options = {}) {\r\n        const { re } = utils;\r\n\r\n        // ensure array, normalize and sort the globs in logical order. this\r\n        // also concats the array first (to prevent mutating the original\r\n        // array).\r\n        const globs = Glob.normalize(globList, options.restrictive);\r\n        const len = globs.length;\r\n        const empty = this._isArray ? [] : {};\r\n\r\n        // if globs is \"\" or [\"\"] or [\"!*\"] or [\"![*]\"] set source to empty and return.\r\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\r\n            this._source = empty;\r\n            return this;\r\n        }\r\n\r\n        const cloned = utils.cloneDeep(this.value);\r\n\r\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\r\n        // if globs only consist of \"*\" or \"[*]\"; set the \"clone\" as source and\r\n        // return.\r\n        if (len === 1 && firstIsWildcard) {\r\n            this._source = cloned;\r\n            return this;\r\n        }\r\n\r\n        let filtered;\r\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\r\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\r\n        // re-process).\r\n        if (firstIsWildcard) {\r\n            filtered = new Notation(cloned);\r\n            globs.shift();\r\n        } else {\r\n            // otherwise we set an empty object or array as the source so that\r\n            // we can add notations/properties to it.\r\n            filtered = new Notation(empty);\r\n        }\r\n\r\n        // iterate through globs\r\n        utils.each(globs, globNotation => {\r\n            // console.log('globNotation', globNotation);\r\n            const g = new Glob(globNotation);\r\n            const { glob, absGlob, isNegated, levels } = g;\r\n            let normalized, emptyValue, eType;\r\n            // check whether the glob ends with `.*` or `[*]` then remove\r\n            // trailing glob note and decide for empty value (if negated). for\r\n            // non-negated, trailing wildcards are already removed by\r\n            // normalization.\r\n            if (absGlob.slice(-2) === '.*') {\r\n                normalized = absGlob.slice(0, -2);\r\n                /* istanbul ignore else */\r\n                if (isNegated) emptyValue = {};\r\n                eType = 'object';\r\n            } else if (absGlob.slice(-3) === '[*]') {\r\n                normalized = absGlob.slice(0, -3);\r\n                /* istanbul ignore else */\r\n                if (isNegated) emptyValue = [];\r\n                eType = 'array';\r\n            } else {\r\n                normalized = absGlob;\r\n            }\r\n\r\n            // we'll check glob vs value integrity if emptyValue is set; and throw if needed.\r\n            const errGlobIntegrity = `Integrity failed for glob '${glob}'. Cannot set empty ${eType} for '${normalized}' which has a type of `; // ...\r\n\r\n            // check if remaining normalized glob has no wildcard stars e.g.\r\n            // \"a.b\" or \"!a.b.c\" etc..\r\n            if (re.WILDCARDS.test(normalized) === false) {\r\n                if (isNegated) {\r\n                    // inspect and directly remove the notation if negated.\r\n                    // we need the inspection for the detailed error below.\r\n                    const insRemove = filtered.inspectRemove(normalized);\r\n                    // console.log('insRemove', insRemove);\r\n\r\n                    // if original glob had `.*` at the end, it means remove\r\n                    // contents (not itself). so we'll set an empty object.\r\n                    // meaning `some.prop` (prop) is removed completely but\r\n                    // `some.prop.*` (prop) results in `{}`. For array notation\r\n                    // (`[*]`), we'll set an empty array.\r\n                    if (emptyValue) {\r\n                        // e.g. for glob `![0].x.*` we expect to set `[0].x = {}`\r\n                        // but if `.x` is not an object (or array), we should fail.\r\n                        const vType = insRemove.type;\r\n                        const errMsg = errGlobIntegrity + `'${vType}'.`;\r\n                        // in non-strict mode, only exceptions are `null` and\r\n                        // `undefined`, for which we won't throw but we'll not\r\n                        // set an empty obj/arr either.\r\n\r\n                        const isValSet = utils.isset(insRemove.value);\r\n                        // on critical type mismatch we throw\r\n                        // or if original value is undefined or null in strict mode we throw\r\n                        if ((isValSet && vType !== eType) || (!isValSet && this.options.strict)) {\r\n                            throw new NotationError(errMsg);\r\n                        }\r\n                        // if parent is an array, we'll insert the value at\r\n                        // index bec. we've removed the item and indexes are\r\n                        // shifted. Otherwise, we'll simply overwrite the\r\n                        // object property value.\r\n                        const setMode = insRemove.parentIsArray ? 'insert' : 'overwrite';\r\n                        // console.log('setting', normalized, emptyValue, setMode);\r\n                        filtered.set(normalized, emptyValue, setMode);\r\n                    }\r\n                } else {\r\n                    // directly set the same notation from the original\r\n                    const insGet = this.inspectGet(normalized); // Notation.create(original).inspectGet ...\r\n                    /* istanbul ignore else */\r\n                    if (insGet.has) filtered.set(normalized, insGet.value, 'overwrite');\r\n                }\r\n                // move to the next\r\n                return true;\r\n            }\r\n\r\n            // if glob has wildcard(s), we'll iterate through keys of the source\r\n            // object and see if (full) notation of each key matches the current\r\n            // glob.\r\n\r\n            // important! we will iterate with eachRight to prevent shifted\r\n            // indexes when removing items from arrays.\r\n            const reverseIterateIfArray = true;\r\n\r\n            _each(this._source, (originalNotation, key, value) => {\r\n                const originalIsCovered = Glob.create(normalized).covers(originalNotation);\r\n                // console.log(' normalized:', normalized, 'covers', originalNotation, '', originalIsCovered);\r\n                if (!originalIsCovered) return true; // break\r\n\r\n                if (this.options.strict && emptyValue) {\r\n                    // since original is covered and we have emptyValue set (due\r\n                    // to trailing wildcard), here we'll check value vs glob\r\n                    // integrity; (only if we're in strict mode).\r\n\r\n                    const vType = utils.type(value);\r\n                    // types and number of levels are the same?\r\n                    if (vType !== eType\r\n                            // we subtract 1 from number of levels bec. the last\r\n                            // note is removed since we have emptyValue set.\r\n                            && Notation.split(originalNotation).length === levels.length - 1) {\r\n                        throw new NotationError(errGlobIntegrity + `'${vType}'.`);\r\n                    }\r\n                }\r\n\r\n                // iterating each note of original notation. i.e.:\r\n                // note1.note2.note3 is iterated from left to right, as:\r\n                // 'note1', 'note1.note2', 'note1.note2.note3'  in order.\r\n                Notation.eachNote(originalNotation, levelNotation => {\r\n                    // console.log('  level ', glob, 'covers', levelNotation, '', g.test(levelNotation));\r\n\r\n                    if (g.test(levelNotation)) {\r\n                        const levelLen = Notation.split(levelNotation).length;\r\n                        /* istanbul ignore else */\r\n                        if (isNegated && levels.length <= levelLen) {\r\n                            // console.log('   removing', levelNotation, 'of', originalNotation);\r\n                            filtered.remove(levelNotation);\r\n                            // we break and return early if removed bec. e.g.\r\n                            // when 'note1.note2' (parent) of\r\n                            // 'note1.note2.note3' is also removed, we no more\r\n                            // have 'note3'.\r\n                            return false;\r\n                        }\r\n                        // console.log('   setting', levelNotation, '=', value);\r\n                        filtered.set(levelNotation, value, 'overwrite');\r\n                    }\r\n                });\r\n            }, reverseIterateIfArray);\r\n        });\r\n        // finally set the filtered's value as the source of our instance and\r\n        // return.\r\n        this._source = filtered.value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the property from the source object, at the given notation.\r\n     *  @alias Notation#delete\r\n     *  @chainable\r\n     *  @param {String} notation - The notation to be inspected.\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *  @throws {NotationError} - If `strict` option is enabled and notation\r\n     *  does not exist.\r\n     *\r\n     *  @example\r\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\r\n     *  Notation.create(obj).remove(\"car.model\");\r\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\r\n     */\r\n    remove(notation) {\r\n        const result = this.inspectRemove(notation);\r\n        // if strict, check if implied index or prop exists\r\n        if (this.options.strict && !result.has) {\r\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\r\n            throw new NotationError(msg + `'${notation}'`);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation#remove`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @returns {Notation} -\r\n     */\r\n    delete(notation) {\r\n        this.remove(notation);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the source collection and adds it to the\r\n     *  destination  only if the source object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} destination - The destination object that the notated\r\n     *  properties will be copied to.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source property\r\n     *  on the destination object. In other words, the copied property will be\r\n     *  renamed to this value before set on the destination object. If not set,\r\n     *  `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `destination` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     *  // source object (obj) is not modified\r\n     */\r\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\r\n        const result = this.inspectGet(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            Notation.create(destination).set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the target collection and adds it to\r\n     *  (own) source object  only if the target object actually has that\r\n     *  property. This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} target - The target collection that the notated\r\n     *  properties will be copied from.\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property from the target object.\r\n     *  @param {String} [newNotation=null] - The notation to set the copied\r\n     *  property on our source collection. In other words, the copied property\r\n     *  will be renamed to this value before set. If not set, `notation`\r\n     *  argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  our collection if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `target` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  // models object is not modified\r\n     */\r\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\r\n        const result = Notation.create(target).inspectGet(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            this.set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the source (own) collection and adds\r\n     *  it to the destination  only if the source collection actually has that\r\n     *  property. This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} destination - The destination collection that the\r\n     *  notated properties will be moved to.\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source\r\n     *  property on the destination object. In other words, the moved property\r\n     *  will be renamed to this value before set on the destination object. If\r\n     *  not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `destination` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\" } }\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     */\r\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\r\n        const result = this.inspectRemove(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            Notation.create(destination).set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the target collection and adds it to (own)\r\n     *  source collection  only if the target object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} target - The target collection that the notated\r\n     *  properties will be moved from.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the target object.\r\n     *  @param {String} [newNotation=null] - The notation to set the target\r\n     *  property on the source object. In other words, the moved property\r\n     *  will be renamed to this value before set on the source object.\r\n     *  If not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the source object if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `target` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  console.log(models);\r\n     *  // {}\r\n     */\r\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\r\n        const result = Notation.create(target).inspectRemove(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            this.set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Renames the notated property of the source collection by the new notation.\r\n     *  @alias Notation#renote\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source collection.\r\n     *  @param {String} newNotation - The new notation for the targeted\r\n     *  property value. If not set, the source collection will not be modified.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\r\n     *  the new notation, if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  Notation.create(obj)\r\n     *      .rename(\"car.brand\", \"carBrand\")\r\n     *      .rename(\"car.model\", \"carModel\");\r\n     *  console.log(obj);\r\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\r\n     */\r\n    rename(notation, newNotation, overwrite) {\r\n        return this.moveTo(this._source, notation, newNotation, overwrite);\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#rename`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {String} newNotation -\r\n     *  @param {Boolean} [overwrite=true] -\r\n     *  @returns {Notation} -\r\n     */\r\n    renote(notation, newNotation, overwrite) {\r\n        return this.rename(notation, newNotation, overwrite);\r\n    }\r\n\r\n    /**\r\n     *  Extracts the property at the given notation to a new object by copying\r\n     *  it from the source collection. This is equivalent to `.copyTo({},\r\n     *  notation, newNotation)`.\r\n     *  @alias Notation#copyToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\r\n     *  console.log(extracted);\r\n     *  // { carBrand: \"Ford\" }\r\n     *  // obj is not modified\r\n     */\r\n    extract(notation, newNotation) {\r\n        const o = {};\r\n        this.copyTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#extract`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {String} newNotation -\r\n     *  @returns {Object} -\r\n     */\r\n    copyToNew(notation, newNotation) {\r\n        return this.extract(notation, newNotation);\r\n    }\r\n\r\n    /**\r\n     *  Extrudes the property at the given notation to a new collection by\r\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\r\n     *  notation, newNotation)`.\r\n     *  @alias Notation#moveToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\r\n     *  console.log(obj);\r\n     *  // { car: { model: \"Mustang\" } }\r\n     *  console.log(extruded);\r\n     *  // { carBrand: \"Ford\" }\r\n     */\r\n    extrude(notation, newNotation) {\r\n        const o = {};\r\n        this.moveTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#extrude`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {String} newNotation -\r\n     *  @returns {Object} -\r\n     */\r\n    moveToNew(notation, newNotation) {\r\n        return this.extrude(notation, newNotation);\r\n    }\r\n\r\n    // --------------------------------\r\n    // STATIC MEMBERS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `Notation` instance.\r\n     *  @chainable\r\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\r\n     *  @param {Object} [options] - Notation options.\r\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\r\n     *      notation path does not exist on the source. (Note that `.inspectGet()`\r\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\r\n     *      set this to `true` and prevent silent failures if you're working\r\n     *      with sensitive data. Regardless of `strict` option, it will always\r\n     *      throw on invalid notation syntax or other crucial failures.\r\n     *\r\n     *  @returns {Notation} - The created instance.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\r\n     *  notation.get('car.model')   //  \"Charger\"\r\n     *  notation.remove('car.model').set('car.color', 'red').value\r\n     *  //  { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\r\n     */\r\n    static create(source, options) {\r\n        if (arguments.length === 0) {\r\n            return new Notation({});\r\n        }\r\n        return new Notation(source, options);\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the given notation string is valid. Note that the star\r\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\r\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\r\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\r\n     *  goes for the negation character/prefix (`!`).\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  Notation.isValid('prop1.prop2.prop3'); // true\r\n     *  Notation.isValid('x'); // true\r\n     *  Notation.isValid('x.arr[0].y'); // true\r\n     *  Notation.isValid('x[\"*\"]'); // true\r\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\r\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\r\n     *  Notation.isValid(null); // false\r\n     */\r\n    static isValid(notation) {\r\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\r\n    }\r\n\r\n    /**\r\n     *  Splits the given notation string into its notes (levels).\r\n     *  @param {String} notation  Notation string to be splitted.\r\n     *  @returns {Array} - A string array of notes (levels).\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     */\r\n    static split(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\r\n        }\r\n        return notation.match(reMATCHER);\r\n    }\r\n\r\n    /**\r\n     *  Joins the given notes into a notation string.\r\n     *  @param {String} notes  Notes (levels) to be joined.\r\n     *  @returns {String}  Joined notation string.\r\n     */\r\n    static join(notes) {\r\n        return utils.joinNotes(notes);\r\n    }\r\n\r\n    /**\r\n     *  Counts the number of notes/levels in the given notation.\r\n     *  @alias Notation.countLevels\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {Number} - Number of notes.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     */\r\n    static countNotes(notation) {\r\n        return Notation.split(notation).length;\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation.countNotes`.\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @returns {Number} -\r\n     */\r\n    static countLevels(notation) {\r\n        return Notation.countNotes(notation);\r\n    }\r\n\r\n    /**\r\n     *  Gets the first (root) note of the notation string.\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {String} - First note.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.first('first.prop2.last'); // \"first\"\r\n     */\r\n    static first(notation) {\r\n        return Notation.split(notation)[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the last note of the notation string.\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {String} - Last note.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.last('first.prop2.last'); // \"last\"\r\n     */\r\n    static last(notation) {\r\n        const list = Notation.split(notation);\r\n        return list[list.length - 1];\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent notation (up to but excluding the last note)\r\n     *  from the notation string.\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\r\n     *  Notation.parent('single'); // null\r\n     */\r\n    static parent(notation) {\r\n        const last = Notation.last(notation);\r\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note/level of the given notation string.\r\n     *  @alias Notation.eachLevel\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within the\r\n     *  callback.\r\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  const notation = 'first.prop2.last';\r\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\r\n     *      console.log(index, note, levelNotation);\r\n     *  });\r\n     *  // 0  \"first\"             \"first\"\r\n     *  // 1  \"first.prop2\"       \"prop2\"\r\n     *  // 2  \"first.prop2.last\"  \"last\"\r\n     */\r\n    static eachNote(notation, callback) {\r\n        const notes = Notation.split(notation);\r\n        const levelNotes = [];\r\n        utils.each(notes, (note, index) => {\r\n            levelNotes.push(note);\r\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\r\n        }, Notation);\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation.eachNote`.\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {Function} callback -\r\n     *  @returns {void}\r\n     */\r\n    static eachLevel(notation, callback) {\r\n        Notation.eachNote(notation, callback);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Error}`\r\n */\r\nNotation.Error = NotationError;\r\n\r\n/**\r\n *  Utility for validating, comparing and sorting dot-notation globs.\r\n *  This is internally used by `Notation` class.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Glob}`\r\n */\r\nNotation.Glob = Glob;\r\n\r\n/**\r\n *  Undocumented\r\n *  @private\r\n */\r\nNotation.utils = utils;\r\n\r\n// --------------------------------\r\n// HELPERS\r\n// --------------------------------\r\n\r\n/**\r\n *  Deep iterates through each note (level) of each item in the given\r\n *  collection.\r\n *  @private\r\n *  @param {Object|Array} collection  A data object or an array, as the source.\r\n *  @param {Function} callback  A function to be executed on each iteration,\r\n *  with the following arguments: `(levelNotation, note, value, collection)`\r\n *  @param {Boolean} [reverseIfArray=false]  Set to `true` to iterate with\r\n *  `eachRight` to prevent shifted indexes when removing items from arrays.\r\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\r\n *  each level or by the end value.  For example, if we have a collection of\r\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\r\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\r\n *  `a.b`.\r\n *  @param {String} [parentNotation]  Storage for parent (previous) notation.\r\n *  @param {Collection} [topSource]  Storage for initial/main collection.\r\n *  @returns {void}\r\n */\r\nfunction _each(collection, callback, reverseIfArray = false, byLevel = false, parentNotation = null, topSource = null) { // eslint-disable-line max-params\r\n    const source = topSource || collection;\r\n    // if (!utils.isCollection(collection)) throw ... // no need\r\n    utils.eachItem(collection, (value, keyOrIndex) => {\r\n        const note = typeof keyOrIndex === 'number'\r\n            ? `[${keyOrIndex}]`\r\n            : keyOrIndex;\r\n        const currentNotation = Notation.join([parentNotation, note]);\r\n        const isCollection = utils.isCollection(value);\r\n        // if it's not a collection we'll execute the callback. if it's a\r\n        // collection but byLevel is set, we'll also execute the callback.\r\n        if (!isCollection || byLevel) {\r\n            if (callback(currentNotation, note, value, source) === false) return false;\r\n        }\r\n        // deep iterating if collection\r\n        if (isCollection) _each(value, callback, reverseIfArray, byLevel, currentNotation, source);\r\n    }, null, reverseIfArray);\r\n}\r\n\r\n// --------------------------------\r\n// EXPORT\r\n// --------------------------------\r\n\r\nexport { Notation };\r\n","\r\nimport { NotationError } from './core/notation.error';\r\n\r\nconst objProto = Object.prototype;\r\nconst symValueOf = typeof Symbol === 'function'\r\n    ? Symbol.prototype.valueOf\r\n    /* istanbul ignore next */\r\n    : null;\r\n\r\n// never use 'g' (global) flag in regexps below\r\nconst VAR = /^[a-z$_][a-z$_\\d]*$/i;\r\nconst ARRAY_NOTE = /^\\[(\\d+)\\]$/;\r\nconst ARRAY_GLOB_NOTE = /^\\[(\\d+|\\*)\\]$/;\r\nconst OBJECT_BRACKETS = /^\\[(?:'(.*)'|\"(.*)\"|`(.*)`)\\]$/;\r\nconst WILDCARD = /^(\\[\\*\\]|\\*)$/;\r\n// matches `*` and `[*]` if outside of quotes.\r\nconst WILDCARDS = /(\\*|\\[\\*\\])(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/;\r\n// matches trailing wildcards at the end of a non-negated glob.\r\n// e.g. `x.y.*[*].*`  $1 = `x.y`, $2 = `.*[*].*`\r\nconst NON_NEG_WILDCARD_TRAIL = /^(?!!)(.+?)(\\.\\*|\\[\\*\\])+$/;\r\nconst NEGATE_ALL = /^!(\\*|\\[\\*\\])$/;\r\n// ending with '.*' or '[*]'\r\n\r\nconst _reFlags = /\\w*$/;\r\n\r\nconst utils = {\r\n\r\n    re: {\r\n        VAR,\r\n        ARRAY_NOTE,\r\n        ARRAY_GLOB_NOTE,\r\n        OBJECT_BRACKETS,\r\n        WILDCARD,\r\n        WILDCARDS,\r\n        NON_NEG_WILDCARD_TRAIL,\r\n        NEGATE_ALL\r\n    },\r\n\r\n    type(o) {\r\n        return objProto.toString.call(o).match(/\\s(\\w+)/i)[1].toLowerCase();\r\n    },\r\n\r\n    isCollection(o) {\r\n        const t = utils.type(o);\r\n        return t === 'object' || t === 'array';\r\n    },\r\n\r\n    isset(o) {\r\n        return o !== undefined && o !== null;\r\n    },\r\n\r\n    ensureArray(o) {\r\n        if (utils.type(o) === 'array') return o;\r\n        return o === null || o === undefined ? [] : [o];\r\n    },\r\n\r\n    // simply returning true will get rid of the \"holes\" in the array.\r\n    // e.g. [0, , 1, , undefined, , , 2, , , null].filter(() => true);\r\n    //  [0, 1, undefined, 2, null]\r\n\r\n    // cleanSparseArray(a) {\r\n    //     return a.filter(() => true);\r\n    // },\r\n\r\n    // added _collectionType for optimization (in loops)\r\n    hasOwn(collection, keyOrIndex, _collectionType) {\r\n        if (!collection) return false;\r\n        const isArr = (_collectionType || utils.type(collection)) === 'array';\r\n        if (!isArr && typeof keyOrIndex === 'string') {\r\n            return keyOrIndex && objProto.hasOwnProperty.call(collection, keyOrIndex);\r\n        }\r\n        if (typeof keyOrIndex === 'number') {\r\n            return keyOrIndex >= 0 && keyOrIndex < collection.length;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    cloneDeep(collection) {\r\n        const t = utils.type(collection);\r\n        switch (t) {\r\n            case 'date':\r\n                return new Date(collection.valueOf());\r\n            case 'regexp': {\r\n                const flags = _reFlags.exec(collection).toString();\r\n                const copy = new collection.constructor(collection.source, flags);\r\n                copy.lastIndex = collection.lastIndex;\r\n                return copy;\r\n            }\r\n            case 'symbol':\r\n                return symValueOf\r\n                    ? Object(symValueOf.call(collection))\r\n                    /* istanbul ignore next */\r\n                    : collection;\r\n            case 'array':\r\n                return collection.map(utils.cloneDeep);\r\n            case 'object': {\r\n                const copy = {};\r\n                // only enumerable string keys\r\n                Object.keys(collection).forEach(k => {\r\n                    copy[k] = utils.cloneDeep(collection[k]);\r\n                });\r\n                return copy;\r\n            }\r\n            // primitives copied over by value\r\n            // case 'string':\r\n            // case 'number':\r\n            // case 'boolean':\r\n            // case 'null':\r\n            // case 'undefined':\r\n            default: // others will be referenced\r\n                return collection;\r\n        }\r\n    },\r\n\r\n    // iterates over elements of an array, executing the callback for each\r\n    // element.\r\n    each(array, callback, thisArg) {\r\n        const len = array.length;\r\n        let index = -1;\r\n        while (++index < len) {\r\n            if (callback.apply(thisArg, [array[index], index, array]) === false) return;\r\n        }\r\n    },\r\n\r\n    eachRight(array, callback, thisArg) {\r\n        let index = array.length;\r\n        while (index--) {\r\n            if (callback.apply(thisArg, [array[index], index, array]) === false) return;\r\n        }\r\n    },\r\n\r\n    eachProp(object, callback, thisArg) {\r\n        const keys = Object.keys(object);\r\n        let index = -1;\r\n        while (++index < keys.length) {\r\n            const key = keys[index];\r\n            if (callback.apply(thisArg, [object[key], key, object]) === false) return;\r\n        }\r\n    },\r\n\r\n    eachItem(collection, callback, thisArg, reverseIfArray = false) {\r\n        if (utils.type(collection) === 'array') {\r\n            // important! we should iterate with eachRight to prevent shifted\r\n            // indexes when removing items from arrays.\r\n            return reverseIfArray\r\n                ? utils.eachRight(collection, callback, thisArg)\r\n                : utils.each(collection, callback, thisArg);\r\n        }\r\n        return utils.eachProp(collection, callback, thisArg);\r\n    },\r\n\r\n    pregQuote(str) {\r\n        const re = /[.\\\\+*?[^\\]$(){}=!<>|:-]/g;\r\n        return String(str).replace(re, '\\\\$&');\r\n    },\r\n\r\n    stringOrArrayOf(o, value) {\r\n        return typeof value === 'string'\r\n            && (o === value\r\n                || (utils.type(o) === 'array' && o.length === 1 && o[0] === value)\r\n            );\r\n    },\r\n\r\n    hasSingleItemOf(arr, itemValue) {\r\n        return arr.length === 1\r\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\r\n    },\r\n\r\n    // remove trailing/redundant wildcards if not negated\r\n    removeTrailingWildcards(glob) {\r\n        // return glob.replace(/(.+?)(\\.\\*|\\[\\*\\])*$/, '$1');\r\n        return glob.replace(NON_NEG_WILDCARD_TRAIL, '$1');\r\n    },\r\n\r\n    normalizeNote(note) {\r\n        if (VAR.test(note)) return note;\r\n        // check array index notation e.g. `[1]`\r\n        let m = note.match(ARRAY_NOTE);\r\n        if (m) return parseInt(m[1], 10);\r\n        // check object bracket notation e.g. `[\"a-b\"]`\r\n        m = note.match(OBJECT_BRACKETS);\r\n        if (m) return (m[1] || m[2] || m[3]);\r\n        throw new NotationError(`Invalid note: '${note}'`);\r\n    },\r\n\r\n    joinNotes(notes) {\r\n        const lastIndex = notes.length - 1;\r\n        return notes.map((current, i) => {\r\n            if (!current) return '';\r\n            const next = lastIndex >= i + 1 ? notes[i + 1] : null;\r\n            const dot = next\r\n                ? next[0] === '[' ? '' : '.'\r\n                : '';\r\n            return current + dot;\r\n        }).join('');\r\n    },\r\n\r\n    getNewNotation(newNotation, notation) {\r\n        const errMsg = `Invalid new notation: '${newNotation}'`;\r\n        // note validations (for newNotation and notation) are already made by\r\n        // other methods in the flow.\r\n        let newN;\r\n        if (typeof newNotation === 'string') {\r\n            newN = newNotation.trim();\r\n            if (!newN) throw new NotationError(errMsg);\r\n            return newN;\r\n        }\r\n        if (notation && !utils.isset(newNotation)) return notation;\r\n        throw new NotationError(errMsg);\r\n    }\r\n\r\n};\r\n\r\nexport { utils };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* istanbul ignore file */\r\nexport * from './core/notation';\r\n"],"names":["setProto","Object","setPrototypeOf","NotationError","_Error","_inherits","_super","_createSuper","_this","message","arguments","length","undefined","_classCallCheck","call","_assertThisInitialized","prototype","defineProperty","enumerable","writable","value","Error","hasOwnProperty","captureStackTrace","stack","_createClass","_wrapNativeSuper","Notation","utils","reMATCHER","reVALIDATOR","RegExp","re","ERR_INVALID","Glob","glob","ins","_inspect","notes","split","absGlob","_","_objectSpread","parent","regexp","key","get","isNegated","toRegExp","slice","last","replace","test","notation","isValid","concat","_covers","covers","intersect","restrictive","_intersect","create","hasMagic","WILDCARDS","g","indexOf","pregQuote","globA","globB","match","a","b","notesA","notesB","fn","_matchesNote","_coversNote","i","bang","len","Math","max","notesI","push","WILDCARD","joinNotes","trim","removeTrailingWildcards","isArrayGlob","normalize","neg","compare","aIdxCompare","_compareArrayItemGlobs","wildCountA","wildCountB","sort","globList","original","ensureArray","list","_negFirstSort","_negLastSort","map","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","inter","hasInverted","_invert","eachRight","indexA","NEGATE_ALL","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","JSON","stringify","splice","_isReverseOf","coversB","coveredByB","keepNeg","keepPos","keep","keys","_compareUnion","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","globsA","globsB","listA","listB","bIsArr","ARRAY_GLOB_NOTE","normalizeNote","_idxVal","note","parseInt","_compArrIdx","lastA","lastB","iA","iB","reANote","_rx","negA","negB","ERR","SOURCE","DEST","NOTATION","NOTA_OBJ","NO_INDEX","NO_PROP","DEFAULT_OPTS","freeze","strict","preserveIndices","source","options","_source","isCollection","_isArray","type","_options","set","each","callback","_each","eachValue","level","eachNote","levelNotation","index","hasOwn","getNotations","clone","cloneDeep","flatten","o","expand","merge","aggregate","inspectGet","result","has","lastNoteNormalized","lastNote","parentIsArray","inspectRemove","parentNotation","hasDefined","defaultValue","msg","mode","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","insertErrMsg","notationsObject","overwrite","separate","notations","_this2","filter","_this3","globs","empty","cloned","firstIsWildcard","filtered","shift","globNotation","levels","emptyValue","eType","errGlobIntegrity","insRemove","vType","errMsg","isValSet","isset","setMode","insGet","reverseIterateIfArray","originalNotation","originalIsCovered","levelLen","remove","_delete","copyTo","destination","newNotation","newN","getNewNotation","copyFrom","target","moveTo","moveFrom","rename","renote","extract","copyToNew","extrude","moveToNew","join","countNotes","countLevels","first","levelNotes","eachLevel","collection","reverseIfArray","byLevel","topSource","eachItem","keyOrIndex","currentNotation","objProto","symValueOf","Symbol","valueOf","VAR","ARRAY_NOTE","OBJECT_BRACKETS","NON_NEG_WILDCARD_TRAIL","_reFlags","toString","toLowerCase","t","_collectionType","isArr","Date","flags","exec","copy","constructor","lastIndex","forEach","k","array","thisArg","apply","eachProp","object","str","String","stringOrArrayOf","hasSingleItemOf","arr","itemValue","m","current","next","dot"],"sourceRoot":""}