{"version":3,"file":"notation.min.js","mappings":"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","sources":["webpack://notation/webpack/universalModuleDefinition","webpack://notation/webpack/bootstrap","webpack://notation/webpack/runtime/define property getters","webpack://notation/webpack/runtime/hasOwnProperty shorthand","webpack://notation/webpack/runtime/make namespace object","webpack://notation/./src/core/notation.error.js","webpack://notation/./src/utils.js","webpack://notation/./src/core/notation.glob.js","webpack://notation/./src/core/notation.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"notation\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"notation\"] = factory();\n\telse\n\t\troot[\"notation\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint consistent-this:0, no-prototype-builtins:0 */\r\n\r\nconst setProto = Object.setPrototypeOf;\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @class\r\n *  @name Notation.Error\r\n */\r\nclass NotationError extends Error {\r\n\r\n    /**\r\n     *  Initializes a new `Notation.Error` instance.\r\n     *  @hideconstructor\r\n     *  @constructs Notation.Error\r\n     *  @param {String} message - The error message.\r\n     */\r\n    constructor(message = '') {\r\n        super(message);\r\n        setProto(this, NotationError.prototype);\r\n\r\n        Object.defineProperty(this, 'name', {\r\n            enumerable: false,\r\n            writable: false,\r\n            value: 'NotationError'\r\n        });\r\n\r\n        Object.defineProperty(this, 'message', {\r\n            enumerable: false,\r\n            writable: true,\r\n            value: message\r\n        });\r\n\r\n        /* istanbul ignore else */\r\n        if (Error.hasOwnProperty('captureStackTrace')) { // V8\r\n            Error.captureStackTrace(this, NotationError);\r\n        } else {\r\n            Object.defineProperty(this, 'stack', {\r\n                enumerable: false,\r\n                writable: false,\r\n                value: (new Error(message)).stack\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport { NotationError };\r\n","\r\nimport { NotationError } from './core/notation.error';\r\n\r\nconst objProto = Object.prototype;\r\nconst symValueOf = typeof Symbol === 'function'\r\n    ? Symbol.prototype.valueOf\r\n    /* istanbul ignore next */\r\n    : null;\r\n\r\n// never use 'g' (global) flag in regexps below\r\nconst VAR = /^[a-z$_][a-z$_\\d]*$/i;\r\nconst ARRAY_NOTE = /^\\[(\\d+)\\]$/;\r\nconst ARRAY_GLOB_NOTE = /^\\[(\\d+|\\*)\\]$/;\r\nconst OBJECT_BRACKETS = /^\\[(?:'(.*)'|\"(.*)\"|`(.*)`)\\]$/;\r\nconst WILDCARD = /^(\\[\\*\\]|\\*)$/;\r\n// matches `*` and `[*]` if outside of quotes.\r\nconst WILDCARDS = /(\\*|\\[\\*\\])(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/;\r\n// matches trailing wildcards at the end of a non-negated glob.\r\n// e.g. `x.y.*[*].*` » $1 = `x.y`, $2 = `.*[*].*`\r\nconst NON_NEG_WILDCARD_TRAIL = /^(?!!)(.+?)(\\.\\*|\\[\\*\\])+$/;\r\nconst NEGATE_ALL = /^!(\\*|\\[\\*\\])$/;\r\n// ending with '.*' or '[*]'\r\n\r\nconst _reFlags = /\\w*$/;\r\n\r\nconst utils = {\r\n\r\n    re: {\r\n        VAR,\r\n        ARRAY_NOTE,\r\n        ARRAY_GLOB_NOTE,\r\n        OBJECT_BRACKETS,\r\n        WILDCARD,\r\n        WILDCARDS,\r\n        NON_NEG_WILDCARD_TRAIL,\r\n        NEGATE_ALL\r\n    },\r\n\r\n    type(o) {\r\n        return objProto.toString.call(o).match(/\\s(\\w+)/i)[1].toLowerCase();\r\n    },\r\n\r\n    isCollection(o) {\r\n        const t = utils.type(o);\r\n        return t === 'object' || t === 'array';\r\n    },\r\n\r\n    isset(o) {\r\n        return o !== undefined && o !== null;\r\n    },\r\n\r\n    ensureArray(o) {\r\n        if (utils.type(o) === 'array') return o;\r\n        return o === null || o === undefined ? [] : [o];\r\n    },\r\n\r\n    // simply returning true will get rid of the \"holes\" in the array.\r\n    // e.g. [0, , 1, , undefined, , , 2, , , null].filter(() => true);\r\n    // ——» [0, 1, undefined, 2, null]\r\n\r\n    // cleanSparseArray(a) {\r\n    //     return a.filter(() => true);\r\n    // },\r\n\r\n    // added _collectionType for optimization (in loops)\r\n    hasOwn(collection, keyOrIndex, _collectionType) {\r\n        if (!collection) return false;\r\n        const isArr = (_collectionType || utils.type(collection)) === 'array';\r\n        if (!isArr && typeof keyOrIndex === 'string') {\r\n            return keyOrIndex && objProto.hasOwnProperty.call(collection, keyOrIndex);\r\n        }\r\n        if (typeof keyOrIndex === 'number') {\r\n            return keyOrIndex >= 0 && keyOrIndex < collection.length;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    cloneDeep(collection) {\r\n        const t = utils.type(collection);\r\n        switch (t) {\r\n            case 'date':\r\n                return new Date(collection.valueOf());\r\n            case 'regexp': {\r\n                const flags = _reFlags.exec(collection).toString();\r\n                const copy = new collection.constructor(collection.source, flags);\r\n                copy.lastIndex = collection.lastIndex;\r\n                return copy;\r\n            }\r\n            case 'symbol':\r\n                return symValueOf\r\n                    ? Object(symValueOf.call(collection))\r\n                    /* istanbul ignore next */\r\n                    : collection;\r\n            case 'array':\r\n                return collection.map(utils.cloneDeep);\r\n            case 'object': {\r\n                const copy = {};\r\n                // only enumerable string keys\r\n                Object.keys(collection).forEach(k => {\r\n                    copy[k] = utils.cloneDeep(collection[k]);\r\n                });\r\n                return copy;\r\n            }\r\n            // primitives copied over by value\r\n            // case 'string':\r\n            // case 'number':\r\n            // case 'boolean':\r\n            // case 'null':\r\n            // case 'undefined':\r\n            default: // others will be referenced\r\n                return collection;\r\n        }\r\n    },\r\n\r\n    // iterates over elements of an array, executing the callback for each\r\n    // element.\r\n    each(array, callback, thisArg) {\r\n        const len = array.length;\r\n        let index = -1;\r\n        while (++index < len) {\r\n            if (callback.apply(thisArg, [array[index], index, array]) === false) return;\r\n        }\r\n    },\r\n\r\n    eachRight(array, callback, thisArg) {\r\n        let index = array.length;\r\n        while (index--) {\r\n            if (callback.apply(thisArg, [array[index], index, array]) === false) return;\r\n        }\r\n    },\r\n\r\n    eachProp(object, callback, thisArg) {\r\n        const keys = Object.keys(object);\r\n        let index = -1;\r\n        while (++index < keys.length) {\r\n            const key = keys[index];\r\n            if (callback.apply(thisArg, [object[key], key, object]) === false) return;\r\n        }\r\n    },\r\n\r\n    eachItem(collection, callback, thisArg, reverseIfArray = false) {\r\n        if (utils.type(collection) === 'array') {\r\n            // important! we should iterate with eachRight to prevent shifted\r\n            // indexes when removing items from arrays.\r\n            return reverseIfArray\r\n                ? utils.eachRight(collection, callback, thisArg)\r\n                : utils.each(collection, callback, thisArg);\r\n        }\r\n        return utils.eachProp(collection, callback, thisArg);\r\n    },\r\n\r\n    pregQuote(str) {\r\n        const re = /[.\\\\+*?[^\\]$(){}=!<>|:-]/g;\r\n        return String(str).replace(re, '\\\\$&');\r\n    },\r\n\r\n    stringOrArrayOf(o, value) {\r\n        return typeof value === 'string'\r\n            && (o === value\r\n                || (utils.type(o) === 'array' && o.length === 1 && o[0] === value)\r\n            );\r\n    },\r\n\r\n    hasSingleItemOf(arr, itemValue) {\r\n        return arr.length === 1\r\n            && (arguments.length === 2 ? arr[0] === itemValue : true);\r\n    },\r\n\r\n    // remove trailing/redundant wildcards if not negated\r\n    removeTrailingWildcards(glob) {\r\n        // return glob.replace(/(.+?)(\\.\\*|\\[\\*\\])*$/, '$1');\r\n        return glob.replace(NON_NEG_WILDCARD_TRAIL, '$1');\r\n    },\r\n\r\n    normalizeNote(note) {\r\n        if (VAR.test(note)) return note;\r\n        // check array index notation e.g. `[1]`\r\n        let m = note.match(ARRAY_NOTE);\r\n        if (m) return parseInt(m[1], 10);\r\n        // check object bracket notation e.g. `[\"a-b\"]`\r\n        m = note.match(OBJECT_BRACKETS);\r\n        if (m) return (m[1] || m[2] || m[3]);\r\n        throw new NotationError(`Invalid note: '${note}'`);\r\n    },\r\n\r\n    joinNotes(notes) {\r\n        const lastIndex = notes.length - 1;\r\n        return notes.map((current, i) => {\r\n            if (!current) return '';\r\n            const next = lastIndex >= i + 1 ? notes[i + 1] : null;\r\n            const dot = next\r\n                ? next[0] === '[' ? '' : '.'\r\n                : '';\r\n            return current + dot;\r\n        }).join('');\r\n    },\r\n\r\n    getNewNotation(newNotation, notation) {\r\n        const errMsg = `Invalid new notation: '${newNotation}'`;\r\n        // note validations (for newNotation and notation) are already made by\r\n        // other methods in the flow.\r\n        let newN;\r\n        if (typeof newNotation === 'string') {\r\n            newN = newNotation.trim();\r\n            if (!newN) throw new NotationError(errMsg);\r\n            return newN;\r\n        }\r\n        if (notation && !utils.isset(newNotation)) return notation;\r\n        throw new NotationError(errMsg);\r\n    }\r\n\r\n};\r\n\r\nexport { utils };\r\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0 */\r\n\r\nimport { Notation } from './notation';\r\nimport { NotationError } from './notation.error';\r\nimport { utils } from '../utils';\r\n\r\n// http://www.linfo.org/wildcard.html\r\n// http://en.wikipedia.org/wiki/Glob_%28programming%29\r\n// http://en.wikipedia.org/wiki/Wildcard_character#Computing\r\n\r\n// created test @ https://regex101.com/r/U08luj/2\r\nconst reMATCHER = /(\\[(\\d+|\\*|\".*\"|'.*')\\]|[a-z$_][a-z$_\\d]*|\\*)/gi; // ! negation should be removed first\r\n// created test @ https://regex101.com/r/mC8unE/3\r\n// /^!?(\\*|[a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\])(\\[(\\d+|\".*\"|'.*'|`.*`|\\*)\\]|\\.[a-z$_][a-z$_\\d]*|\\.\\*)*$/i\r\nconst reVALIDATOR = new RegExp(\r\n    '^'\r\n    + '!?('                             // optional negation, only in the front\r\n    + '\\\\*'                             // wildcard star\r\n    + '|'                               // OR\r\n    + '[a-z$_][a-z$_\\\\d]*'              // JS variable syntax\r\n    + '|'                               // OR\r\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // array index or wildcard, or object bracket notation\r\n    + ')'                               // exactly once\r\n    + '('\r\n    + '\\\\[(\\\\d+|\\\\*|\".*\"|\\'.*\\')\\\\]'    // followed by same\r\n    + '|'                               // OR\r\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'           // dot, then JS variable syntax\r\n    + '|'                               // OR\r\n    + '\\\\.\\\\*'                          // dot, then wildcard star\r\n    + ')*'                              // (both) may repeat any number of times\r\n    + '$'\r\n    , 'i'\r\n);\r\n\r\nconst { re } = utils;\r\nconst ERR_INVALID = 'Invalid glob notation: ';\r\n\r\n/**\r\n *  `Notation.Glob` is a utility for validating, comparing and sorting\r\n *  dot-notation globs.\r\n *\r\n *  You can use {@link http://www.linfo.org/wildcard.html|wildcard} stars `*`\r\n *  and negate the notation by prepending a bang `!`. A star will include all\r\n *  the properties at that level and a negated notation will be excluded.\r\n *  @name Glob\r\n *  @memberof Notation\r\n *  @class\r\n *\r\n *  @example\r\n *  // for the following object;\r\n *  { name: 'John', billing: { account: { id: 1, active: true } } };\r\n *\r\n *  'billing.account.*'  // represents value `{ id: 1, active: true }`\r\n *  'billing.account.id' // represents value `1`\r\n *  '!billing.account.*' // represents value `{ name: 'John' }`\r\n *  'name' // represents `'John'`\r\n *  '*' // represents the whole object\r\n *\r\n *  @example\r\n *  var glob = new Notation.Glob('billing.account.*');\r\n *  glob.test('billing.account.id'); // true\r\n */\r\nclass Glob {\r\n\r\n    /**\r\n     *  Constructs a `Notation.Glob` object with the given glob string.\r\n     *  @constructs Notation.Glob\r\n     *  @param {String} glob - Notation string with globs.\r\n     *\r\n     *  @throws {NotationError} - If given notation glob is invalid.\r\n     */\r\n    constructor(glob) {\r\n        const ins = Glob._inspect(glob);\r\n        const notes = Glob.split(ins.absGlob);\r\n        this._ = {\r\n            ...ins,\r\n            notes,\r\n            // below props will be set at first getter call\r\n            parent: undefined, // don't set to null\r\n            regexp: undefined\r\n        };\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE PROPERTIES\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets the normalized glob notation string.\r\n     *  @name Notation.Glob#glob\r\n     *  @type {String}\r\n     */\r\n    get glob() {\r\n        return this._.glob;\r\n    }\r\n\r\n    /**\r\n     *  Gets the absolute glob notation without the negation prefix `!` and\r\n     *  redundant trailing wildcards.\r\n     *  @name Notation.Glob#absGlob\r\n     *  @type {String}\r\n     */\r\n    get absGlob() {\r\n        return this._.absGlob;\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether this glob is negated with a `!` prefix.\r\n     *  @name Notation.Glob#isNegated\r\n     *  @type {Boolean}\r\n     */\r\n    get isNegated() {\r\n        return this._.isNegated;\r\n    }\r\n\r\n    /**\r\n     *  Represents this glob in regular expressions.\r\n     *  Note that the negation prefix (`!`) is ignored, if any.\r\n     *  @name Notation.Glob#regexp\r\n     *  @type {RegExp}\r\n     */\r\n    get regexp() {\r\n        // setting on first call instead of in constructor, for performance\r\n        // optimization.\r\n        this._.regexp = this._.regexp || Glob.toRegExp(this.absGlob);\r\n        return this._.regexp;\r\n    }\r\n\r\n    /**\r\n     *  List of notes (levels) of this glob notation. Note that trailing,\r\n     *  redundant wildcards are removed from the original glob notation.\r\n     *  @name Notation.Glob#notes\r\n     *  @alias Notation.Glob#levels\r\n     *  @type {Array}\r\n     */\r\n    get notes() {\r\n        return this._.notes;\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation.Glob#notes`.\r\n     *  @private\r\n     *  @name Notation.Glob#notes\r\n     *  @alias Notation.Glob#levels\r\n     *  @type {Array}\r\n     */\r\n    get levels() {\r\n        return this._.notes;\r\n    }\r\n\r\n    /**\r\n     *  Gets the first note of this glob notation.\r\n     *  @name Notation.Glob#first\r\n     *  @type {String}\r\n     */\r\n    get first() {\r\n        return this.notes[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the last note of this glob notation.\r\n     *  @name Notation.Glob#last\r\n     *  @type {String}\r\n     */\r\n    get last() {\r\n        return this.notes[this.notes.length - 1];\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent notation (up to but excluding the last note) from the\r\n     *  glob notation string. Note that initially, trailing/redundant wildcards\r\n     *  are removed.\r\n     *  @name Notation.Glob#parent\r\n     *  @type {String}\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create;\r\n     *  glob('first.second.*').parent;   // \"first.second\"\r\n     *  glob('*.x.*').parent;            // \"*\" (\"*.x.*\" normalizes to \"*.x\")\r\n     *  glob('*').parent;                // null (no parent)\r\n     */\r\n    get parent() {\r\n        // setting on first call instead of in constructor, for performance\r\n        // optimization.\r\n        if (this._.parent === undefined) {\r\n            this._.parent = this.notes.length > 1\r\n                ? this.absGlob.slice(0, -this.last.length).replace(/\\.$/, '')\r\n                : null;\r\n        }\r\n        return this._.parent;\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE METHODS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Checks whether the given notation value matches the source notation\r\n     *  glob.\r\n     *  @name Notation.Glob#test\r\n     *  @function\r\n     *  @param {String} notation - The notation string to be tested. Cannot have\r\n     *  any globs.\r\n     *  @returns {Boolean} -\r\n     *  @throws {NotationError} - If given `notation` is not valid or contains\r\n     *  any globs.\r\n     *\r\n     *  @example\r\n     *  const glob = new Notation.Glob('!prop.*.name');\r\n     *  glob.test(\"prop.account.name\"); // true\r\n     */\r\n    test(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(`Invalid notation: '${notation}'`);\r\n        }\r\n        // return this.regexp.test(notation);\r\n        return Glob._covers(this, notation);\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether this glob notation can represent (or cover) the given\r\n     *  glob notation. Note that negation prefix is ignored, if any.\r\n     *  @name Notation.Glob#covers\r\n     *  @function\r\n     *\r\n     *  @param {String|Array|Glob} glob  Glob notation string, glob\r\n     *  notes array or a `Notation.Glob` instance.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create;\r\n     *  glob('*.y').covers('x.y')      // true\r\n     *  glob('x[*].y').covers('x[*]')  // false\r\n     */\r\n    covers(glob) {\r\n        return Glob._covers(this, glob);\r\n    }\r\n\r\n    /**\r\n     *  Gets the intersection of this and the given glob notations. When\r\n     *  restrictive, if any one of them is negated, the outcome is negated.\r\n     *  Otherwise, only if both of them are negated, the outcome is negated.\r\n     *  @name Notation.Glob#intersect\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Second glob to be used.\r\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\r\n     *  be negated when one of the globs is negated.\r\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create;\r\n     *  glob('x.*').intersect('!*.y')         // 'x.y'\r\n     *  glob('x.*').intersect('!*.y', true)   // '!x.y'\r\n     */\r\n    intersect(glob, restrictive = false) {\r\n        return Glob._intersect(this.glob, glob, restrictive);\r\n    }\r\n\r\n    // --------------------------------\r\n    // STATIC MEMBERS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `Notation.Glob` instance\r\n     *  with the given glob string.\r\n     *  @name Notation.Glob.create\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - The source notation glob.\r\n     *  @returns {Glob} -\r\n     *\r\n     *  @example\r\n     *  const glob = Notation.Glob.create(strGlob);\r\n     *  // equivalent to:\r\n     *  const glob = new Notation.Glob(strGlob);\r\n     */\r\n    static create(glob) {\r\n        return new Glob(glob);\r\n    }\r\n\r\n    // Created test at: https://regex101.com/r/tJ7yI9/4\r\n    /**\r\n     *  Validates the given notation glob.\r\n     *  @name Notation.Glob.isValid\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Notation glob to be validated.\r\n     *  @returns {Boolean} -\r\n     */\r\n    static isValid(glob) {\r\n        return typeof glob === 'string' && reVALIDATOR.test(glob);\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether the given glob notation includes any valid wildcards\r\n     *  (`*`) or negation bang prefix (`!`).\r\n     *  @name Notation.Glob.hasMagic\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Glob notation to be checked.\r\n     *  @returns {Boolean} -\r\n     */\r\n    static hasMagic(glob) {\r\n        return Glob.isValid(glob) && (re.WILDCARDS.test(glob) || glob[0] === '!');\r\n    }\r\n\r\n    /**\r\n     *  Gets a regular expressions instance from the given glob notation.\r\n     *  Note that the bang `!` prefix will be ignored if the given glob is negated.\r\n     *  @name Notation.Glob.toRegExp\r\n     *  @function\r\n     *\r\n     *  @param {String} glob - Glob notation to be converted.\r\n     *\r\n     *  @returns {RegExp} - A `RegExp` instance from the glob.\r\n     *\r\n     *  @throws {NotationError} - If given notation glob is invalid.\r\n     */\r\n    static toRegExp(glob) {\r\n        if (!Glob.isValid(glob)) {\r\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\r\n        }\r\n\r\n        let g = glob.indexOf('!') === 0 ? glob.slice(1) : glob;\r\n        g = utils.pregQuote(g)\r\n            // `[*]` always represents array index e.g. `[1]`. so we'd replace\r\n            // `\\[\\*\\]` with `\\[\\d+\\]` but we should also watch for quotes: e.g.\r\n            // `[\"x[*]y\"]`\r\n            .replace(/\\\\\\[\\\\\\*\\\\\\](?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '\\\\[\\\\d+\\\\]')\r\n            // `*` within quotes (e.g. ['*']) is non-wildcard, just a regular star char.\r\n            // `*` outside of quotes is always JS variable syntax e.g. `prop.*`\r\n            .replace(/\\\\\\*(?=(?:[^\"]|\"[^\"]*\")*$)(?=(?:[^']|'[^']*')*$)/g, '[a-z$_][a-z$_\\\\d]*')\r\n            .replace(/\\\\\\?/g, '.');\r\n        return new RegExp('^' + g + '(?:[\\\\[\\\\.].+|$)', 'i');\r\n        // it should either end ($) or continue with a dot or bracket. So for\r\n        // example, `company.*` will produce `/^company\\.[a-z$_][a-z$_\\\\d]*(?:[\\\\[|\\\\.].+|$)/`\r\n        // which will match both `company.name` and `company.address.street` but\r\n        // will not match `some.company.name`. Also `!password` will not match\r\n        // `!password_reset`.\r\n    }\r\n\r\n    /**\r\n     *  Specifies whether first glob notation can represent (or cover) the\r\n     *  second.\r\n     *  @name Notation.Glob._covers\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {String|Object|Glob} globA  Source glob notation string\r\n     *  or inspection result object or `Notation.Glob` instance.\r\n     *  @param {String|Object|Glob} globB  Glob notation string or\r\n     *  inspection result object or `Notation.Glob` instance.\r\n     *  @param {Boolean} [match=false]  Check whether notes match instead of\r\n     *  `globA` covers `globB`.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  const { covers } = Notation.Glob;\r\n     *  covers('*.y', 'x.y')        // true\r\n     *  covers('x.y', '*.y')        // false\r\n     *  covers('x.y', '*.y', true)  // true\r\n     *  covers('x[*].y', 'x[*]')    // false\r\n     */\r\n    static _covers(globA, globB, match = false) {\r\n        const a = typeof globA === 'string'\r\n            ? new Glob(globA)\r\n            : globA; // assume (globA instanceof Notation.Glob || utils.type(globA) === 'object')\r\n\r\n        const b = typeof globB === 'string'\r\n            ? new Glob(globB)\r\n            : globB;\r\n\r\n        const notesA = a.notes || Glob.split(a.absGlob);\r\n        const notesB = b.notes || Glob.split(b.absGlob);\r\n\r\n        if (!match) {\r\n            // !x.*.* does not cover !x.* or x.* bec. !x.*.* ≠ x.* ≠ x\r\n            // x.*.* covers x.* bec. x.*.* = x.* = x\r\n            if (a.isNegated && notesA.length > notesB.length) return false;\r\n        }\r\n\r\n        let covers = true;\r\n        const fn = match ? _matchesNote : _coversNote;\r\n        for (let i = 0; i < notesA.length; i++) {\r\n            if (!fn(notesA[i], notesB[i])) {\r\n                covers = false;\r\n                break;\r\n            }\r\n        }\r\n        return covers;\r\n    }\r\n\r\n    /**\r\n     *  Gets the intersection notation of two glob notations. When restrictive,\r\n     *  if any one of them is negated, the outcome is negated. Otherwise, only\r\n     *  if both of them are negated, the outcome is negated.\r\n     *  @name Notation.Glob._intersect\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {String} globA - First glob to be used.\r\n     *  @param {String} globB - Second glob to be used.\r\n     *  @param {Boolean} [restrictive=false] - Whether the intersection should\r\n     *  be negated when one of the globs is negated.\r\n     *  @returns {String} - Intersection notation if any; otherwise `null`.\r\n     *  @example\r\n     *  _intersect('!*.y', 'x.*', false)     // 'x.y'\r\n     *  _intersect('!*.y', 'x.*', true)      // '!x.y'\r\n     */\r\n    static _intersect(globA, globB, restrictive = false) {\r\n        // const bang = restrictive\r\n        //     ? (globA[0] === '!' || globB[0] === '!' ? '!' : '')\r\n        //     : (globA[0] === '!' && globB[0] === '!' ? '!' : '');\r\n\r\n        const notesA = Glob.split(globA, true);\r\n        const notesB = Glob.split(globB, true);\r\n\r\n        let bang;\r\n        if (restrictive) {\r\n            bang = globA[0] === '!' || globB[0] === '!' ? '!' : '';\r\n        } else {\r\n            if (globA[0] === '!' && globB[0] === '!') {\r\n                bang = '!';\r\n            } else {\r\n                bang = ((notesA.length > notesB.length && globA[0] === '!')\r\n                        || (notesB.length > notesA.length && globB[0] === '!'))\r\n                    ? '!'\r\n                    : '';\r\n            }\r\n        }\r\n\r\n        const len = Math.max(notesA.length, notesB.length);\r\n        let notesI = [];\r\n        let a, b;\r\n        //   x.*  ∩  *.y   »  x.y\r\n        // x.*.*  ∩  *.y   »  x.y.*\r\n        // x.*.z  ∩  *.y   »  x.y.z\r\n        //   x.y  ∩  *.b   »  (n/a)\r\n        //   x.y  ∩  a.*   »  (n/a)\r\n        for (let i = 0; i < len; i++) {\r\n            a = notesA[i];\r\n            b = notesB[i];\r\n            if (a === b) {\r\n                notesI.push(a);\r\n            } else if (a && re.WILDCARD.test(a)) {\r\n                if (!b) {\r\n                    notesI.push(a);\r\n                } else {\r\n                    notesI.push(b);\r\n                }\r\n            } else if (b && re.WILDCARD.test(b)) {\r\n                if (!a) {\r\n                    notesI.push(b);\r\n                } else {\r\n                    notesI.push(a);\r\n                }\r\n            } else if (a && !b) {\r\n                notesI.push(a);\r\n            } else if (!a && b) {\r\n                notesI.push(b);\r\n            } else { // if (a !== b) {\r\n                notesI = [];\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (notesI.length > 0) return bang + utils.joinNotes(notesI);\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *  Undocumented.\r\n     *  @name Notation.Glob._inspect\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {String} glob -\r\n     *  @returns {Object} -\r\n     */\r\n    static _inspect(glob) {\r\n        let g = glob.trim();\r\n        if (!Glob.isValid(g)) {\r\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\r\n        }\r\n        const isNegated = g[0] === '!';\r\n        // trailing wildcards are only redundant if not negated\r\n        if (!isNegated) g = utils.removeTrailingWildcards(g);\r\n        const absGlob = isNegated ? g.slice(1) : g;\r\n        return {\r\n            glob: g,\r\n            absGlob,\r\n            isNegated,\r\n            // e.g. [*] or [1] are array globs. [\"1\"] is not.\r\n            isArrayGlob: (/^\\[[^'\"]/).test(absGlob)\r\n        };\r\n    }\r\n\r\n    /**\r\n     *  Splits the given glob notation string into its notes (levels). Note that\r\n     *  this will exclude the `!` negation prefix, if it exists.\r\n     *  @name Notation.Glob.split\r\n     *  @function\r\n     *\r\n     *  @param {String} glob  Glob notation string to be splitted.\r\n     *  @param {String} [normalize=false]  Whether to remove trailing, redundant\r\n     *  wildcards.\r\n     *  @returns {Array} - A string array of glob notes (levels).\r\n     *  @throws {NotationError} - If given glob notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.Glob.split('*.list[2].prop')  // ['*', 'list', '[2]', 'prop']\r\n     *  // you can get the same result from the .notes property of a Notation.Glob instance.\r\n     */\r\n    static split(glob, normalize = false) {\r\n        if (!Glob.isValid(glob)) {\r\n            throw new NotationError(`${ERR_INVALID} '${glob}'`);\r\n        }\r\n        const neg = glob[0] === '!';\r\n        // trailing wildcards are redundant only when not negated\r\n        const g = !neg && normalize ? utils.removeTrailingWildcards(glob) : glob;\r\n        return g.replace(/^!/, '').match(reMATCHER);\r\n    }\r\n\r\n    /**\r\n     *  Compares two given notation globs and returns an integer value as a\r\n     *  result. This is generally used to sort glob arrays. Loose globs (with\r\n     *  stars especially closer to beginning of the glob string) and globs\r\n     *  representing the parent/root of the compared property glob come first.\r\n     *  Verbose/detailed/exact globs come last. (`* < *.abc < abc`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. So\r\n     *  this works both for `*, store.address.street, !store.address` and `*,\r\n     *  store.address, !store.address.street`. For cases such as `prop.id` vs\r\n     *  `!prop.id` which represent the same property; the negated glob comes\r\n     *  last.\r\n     *  @name Notation.Glob.compare\r\n     *  @function\r\n     *\r\n     *  @param {String} globA - First notation glob to be compared.\r\n     *  @param {String} globB - Second notation glob to be compared.\r\n     *\r\n     *  @returns {Number} - Returns `-1` if `globA` comes first, `1` if `globB`\r\n     *  comes first and `0` if equivalent priority.\r\n     *\r\n     *  @throws {NotationError} - If either `globA` or `globB` is invalid glob\r\n     *  notation.\r\n     *\r\n     *  @example\r\n     *  const { compare } = Notation.Glob;\r\n     *  compare('*', 'info.user')               // -1\r\n     *  compare('*', '[*]')                     // 0\r\n     *  compare('info.*.name', 'info.user')     // 1\r\n     */\r\n    static compare(globA, globB) {\r\n        // trivial case, both are exactly the same!\r\n        // or both are wildcard e.g. `*` or `[*]`\r\n        if (globA === globB || (re.WILDCARD.test(globA) && re.WILDCARD.test(globB))) return 0;\r\n\r\n        const a = new Glob(globA);\r\n        const b = new Glob(globB);\r\n\r\n        // Check depth (number of levels)\r\n        if (a.notes.length === b.notes.length) {\r\n            // check and compare if these are globs that represent items in the\r\n            // \"same\" array. if not, this will return 0.\r\n            const aIdxCompare = _compareArrayItemGlobs(a, b);\r\n            // we'll only continue comparing if 0 is returned\r\n            if (aIdxCompare !== 0) return aIdxCompare;\r\n\r\n            // count wildcards\r\n            const wildCountA = (a.absGlob.match(re.WILDCARDS) || []).length;\r\n            const wildCountB = (b.absGlob.match(re.WILDCARDS) || []).length;\r\n            if (wildCountA === wildCountB) {\r\n                // check for negation\r\n                if (!a.isNegated && b.isNegated) return -1;\r\n                if (a.isNegated && !b.isNegated) return 1;\r\n                // both are negated or neither are, return alphabetical\r\n                return a.absGlob < b.absGlob ? -1 : (a.absGlob > b.absGlob ? 1 : 0);\r\n            }\r\n            return wildCountA > wildCountB ? -1 : 1;\r\n        }\r\n\r\n        return a.notes.length < b.notes.length ? -1 : 1;\r\n    }\r\n\r\n    /**\r\n     *  Sorts the notation globs in the given array by their priorities. Loose\r\n     *  globs (with stars especially closer to beginning of the glob string);\r\n     *  globs representing the parent/root of the compared property glob come\r\n     *  first. Verbose/detailed/exact globs come last. (`* < *.y < x.y`).\r\n     *\r\n     *  For instance; `store.address` comes before `store.address.street`. For\r\n     *  cases such as `prop.id` vs `!prop.id` which represent the same property;\r\n     *  the negated glob wins (comes last).\r\n     *  @name Notation.Glob.sort\r\n     *  @function\r\n     *\r\n     *  @param {Array} globList - The notation globs array to be sorted. The\r\n     *  passed array reference is modified.\r\n     *  @returns {Array} - Logically sorted globs array.\r\n     *\r\n     *  @example\r\n     *  Notation.Glob.sort(['!prop.*.name', 'prop.*', 'prop.id']) // ['prop.*', 'prop.id', '!prop.*.name'];\r\n     */\r\n    static sort(globList) {\r\n        return globList.sort(Glob.compare);\r\n    }\r\n\r\n    /**\r\n     *  Normalizes the given notation globs array by removing duplicate or\r\n     *  redundant items, eliminating extra verbosity (also with intersection\r\n     *  globs) and returns a priority-sorted globs array.\r\n     *\r\n     *  <ul>\r\n     *  <li>If any exact duplicates found, all except first is removed.\r\n     *  <br />example: `['car', 'dog', 'car']` normalizes to `['car', 'dog']`.</li>\r\n     *  <li>If both normal and negated versions of a glob are found, negated wins.\r\n     *  <br />example: `['*', 'id', '!id']` normalizes to `['*', '!id']`.</li>\r\n     *  <li>If a glob is covered by another, it's removed.\r\n     *  <br />example: `['car.*', 'car.model']` normalizes to `['car']`.</li>\r\n     *  <li>If a negated glob is covered by another glob, it's kept.\r\n     *  <br />example: `['*', 'car', '!car.model']` normalizes as is.</li>\r\n     *  <li>If a negated glob is not covered by another or it does not cover any other;\r\n     *  then we check for for intersection glob. If found, adds them to list;\r\n     *  removes the original negated.\r\n     *  <br />example: `['car.*', '!*.model']` normalizes as to `['car', '!car.model']`.</li>\r\n     *  <li>In restrictive mode; if a glob is covered by another negated glob, it's removed.\r\n     *  Otherwise, it's kept.\r\n     *  <br />example: `['*', '!car.*', 'car.model']` normalizes to `['*', '!car']` if restrictive.</li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.normalize\r\n     *  @function\r\n     *\r\n     *  @param {Array} globList - Notation globs array to be normalized.\r\n     *  @param {Boolean} [restrictive=false] - Whether negated items strictly\r\n     *  remove every match. Note that, regardless of this option, if any item has an\r\n     *  exact negated version; non-negated is always removed.\r\n     *  @returns {Array} -\r\n     *\r\n     *  @throws {NotationError} - If any item in globs list is invalid.\r\n     *\r\n     *  @example\r\n     *  const { normalize } = Notation.Glob;\r\n     *  normalize(['*', '!id', 'name', '!car.model', 'car.*', 'id', 'name']); // ['*', '!id', '!car.model']\r\n     *  normalize(['!*.id', 'user.*', 'company']); // ['company', 'user', '!company.id', '!user.id']\r\n     *  normalize(['*', 'car.model', '!car.*']); // [\"*\", \"!car.*\", \"car.model\"]\r\n     *  // restrictive normalize:\r\n     *  normalize(['*', 'car.model', '!car.*'], true); // [\"*\", \"!car.*\"]\r\n     */\r\n    static normalize(globList, restrictive = false) {\r\n        const { _inspect, _covers, _intersect } = Glob;\r\n\r\n        const original = utils.ensureArray(globList);\r\n        if (original.length === 0) return [];\r\n\r\n        const list = original\r\n            // prevent mutation\r\n            .concat()\r\n            // move negated globs to top so that we inspect non-negated globs\r\n            // against others first. when complete, we'll sort with our\r\n            // .compare() function.\r\n            .sort(restrictive ? _negFirstSort : _negLastSort)\r\n            // turning string array into inspect-obj array, so that we'll not\r\n            // run _inspect multiple times in the inner loop. this also\r\n            // pre-validates each glob.\r\n            .map(_inspect);\r\n\r\n        // early return if we have a single item\r\n        if (list.length === 1) {\r\n            const g = list[0];\r\n            // single negated item is redundant\r\n            if (g.isNegated) return [];\r\n            // return normalized\r\n            return [g.glob];\r\n        }\r\n\r\n        // flag to return an empty array (in restrictive mode), if true.\r\n        let negateAll = false;\r\n\r\n        // we'll push keepers in this array\r\n        let normalized = [];\r\n        // we'll need to remember excluded globs, so that we can move to next\r\n        // item early.\r\n        const ignored = {};\r\n\r\n        // storage to keep intersections.\r\n        // using an object to prevent duplicates.\r\n        let intersections = {};\r\n\r\n        function checkAddIntersection(gA, gB) {\r\n            const inter = _intersect(gA, gB, restrictive);\r\n            if (!inter) return;\r\n            // if the intersection result has an inverted version in the\r\n            // original list, don't add this.\r\n            const hasInverted = restrictive ? false : original.indexOf(_invert(inter)) >= 0;\r\n            // also if intersection result is in the current list, don't add it.\r\n            if (list.indexOf(inter) >= 0 || hasInverted) return;\r\n            intersections[inter] = inter;\r\n        }\r\n\r\n        // iterate each glob by comparing it to remaining globs.\r\n        utils.eachRight(list, (a, indexA) => {\r\n\r\n            // if `strict` is enabled, return empty if a negate-all is found\r\n            // (which itself is also redundant if single): '!*' or '![*]'\r\n            if (re.NEGATE_ALL.test(a.glob)) {\r\n                negateAll = true;\r\n                if (restrictive) return false;\r\n            }\r\n\r\n            // flags\r\n            let duplicate = false;\r\n            let hasExactNeg = false;\r\n            // flags for negated\r\n            let negCoversPos = false;\r\n            let negCoveredByPos = false;\r\n            let negCoveredByNeg = false;\r\n            // flags for non-negated (positive)\r\n            let posCoversPos = false;\r\n            let posCoveredByNeg = false;\r\n            let posCoveredByPos = false;\r\n\r\n            utils.eachRight(list, (b, indexB) => {\r\n                // don't inspect glob with itself\r\n                if (indexA === indexB) return; // move to next\r\n                // console.log(indexA, a.glob, 'vs', b.glob);\r\n\r\n                // e.g. ['x.y.z', '[1].x', 'c'] » impossible! the tested source\r\n                // object cannot be both an array and an object.\r\n                if (a.isArrayGlob !== b.isArrayGlob) {\r\n                    throw new NotationError(`Integrity failed. Cannot have both object and array notations for root level: ${JSON.stringify(original)}`);\r\n                }\r\n\r\n                // remove if duplicate\r\n                if (a.glob === b.glob) {\r\n                    list.splice(indexA, 1);\r\n                    duplicate = true;\r\n                    return false; // break out\r\n                }\r\n\r\n                // remove if positive has an exact negated (negated wins when\r\n                // normalized) e.g. ['*', 'a', '!a'] => ['*', '!a']\r\n                if (!a.isNegated && _isReverseOf(a, b)) {\r\n                    // list.splice(indexA, 1);\r\n                    ignored[a.glob] = true;\r\n                    hasExactNeg = true;\r\n                    return false; // break out\r\n                }\r\n\r\n                // if already excluded b, go on to next\r\n                if (ignored[b.glob]) return; // next\r\n\r\n                const coversB = _covers(a, b);\r\n                const coveredByB = coversB ? false : _covers(b, a);\r\n                if (a.isNegated) {\r\n                    if (b.isNegated) {\r\n                        // if negated (a) covered by any other negated (b); remove (a)!\r\n                        if (coveredByB) {\r\n                            negCoveredByNeg = true;\r\n                            // list.splice(indexA, 1);\r\n                            ignored[a.glob] = true;\r\n                            return false; // break out\r\n                        }\r\n                    } else {\r\n                        /* istanbul ignore if */\r\n                        if (coversB) negCoversPos = true;\r\n                        if (coveredByB) negCoveredByPos = true;\r\n                        // try intersection if none covers the other and only\r\n                        // one of them is negated.\r\n                        if (!coversB && !coveredByB) {\r\n                            checkAddIntersection(a.glob, b.glob);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (b.isNegated) {\r\n                        // if positive (a) covered by any negated (b); remove (a)!\r\n                        if (coveredByB) {\r\n                            posCoveredByNeg = true;\r\n                            if (restrictive) {\r\n                                // list.splice(indexA, 1);\r\n                                ignored[a.glob] = true;\r\n                                return false; // break out\r\n                            }\r\n                            return; // next\r\n                        }\r\n                        // try intersection if none covers the other and only\r\n                        // one of them is negated.\r\n                        if (!coversB && !coveredByB) {\r\n                            checkAddIntersection(a.glob, b.glob);\r\n                        }\r\n                    } else {\r\n                        if (coversB) posCoversPos = coversB;\r\n                        // if positive (a) covered by any other positive (b); remove (a)!\r\n                        if (coveredByB) {\r\n                            posCoveredByPos = true;\r\n                            if (restrictive) {\r\n                                // list.splice(indexA, 1);\r\n                                return false; // break out\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n            // const keepNeg = (negCoversPos || negCoveredByPos) && !negCoveredByNeg;\r\n            const keepNeg = restrictive\r\n                ? (negCoversPos || negCoveredByPos) && negCoveredByNeg === false\r\n                : negCoveredByPos && negCoveredByNeg === false;\r\n            const keepPos = restrictive\r\n                ? (posCoversPos || posCoveredByPos === false) && posCoveredByNeg === false\r\n                : posCoveredByNeg || posCoveredByPos === false;\r\n            const keep = duplicate === false\r\n                && hasExactNeg === false\r\n                && (a.isNegated ? keepNeg : keepPos);\r\n\r\n            if (keep) {\r\n                normalized.push(a.glob);\r\n            } else {\r\n                // this is excluded from final (normalized) list, so mark as\r\n                // ignored (don't remove from \"list\" for now)\r\n                ignored[a.glob] = true;\r\n            }\r\n        });\r\n\r\n        if (restrictive && negateAll) return [];\r\n\r\n        intersections = Object.keys(intersections);\r\n        if (intersections.length > 0) {\r\n            // merge normalized list with intersections if any\r\n            normalized = normalized.concat(intersections);\r\n            // we have new (intersection) items, so re-normalize\r\n            return Glob.normalize(normalized, restrictive);\r\n        }\r\n\r\n        return Glob.sort(normalized);\r\n    }\r\n\r\n    /**\r\n     *  Undocumented. See `.union()`\r\n     *  @name Notation.Glob._compareUnion\r\n     *  @function\r\n     *  @private\r\n     *\r\n     *  @param {Array} globsListA -\r\n     *  @param {Array} globsListB -\r\n     *  @param {Boolean} restrictive -\r\n     *  @param {Array} union -\r\n     *  @returns {Array} -\r\n     */\r\n    static _compareUnion(globsListA, globsListB, restrictive, union = []) {\r\n        const { _covers } = Glob;\r\n\r\n        const { _inspect, _intersect } = Glob;\r\n\r\n        utils.eachRight(globsListA, globA => {\r\n            if (union.indexOf(globA) >= 0) return; // next\r\n\r\n            const a = _inspect(globA);\r\n\r\n            // if wildcard only, add...\r\n            if (re.WILDCARD.test(a.absGlob)) {\r\n                union.push(a.glob); // push normalized glob\r\n                return; // next\r\n            }\r\n\r\n            let notCovered = false;\r\n            let hasExact = false;\r\n            let negCoversNeg = false;\r\n            let posCoversNeg = false;\r\n            let posCoversPos = false;\r\n            let negCoversPos = false;\r\n\r\n            const intersections = [];\r\n\r\n            utils.eachRight(globsListB, globB => {\r\n\r\n                // keep if has exact in the other\r\n                if (globA === globB) hasExact = true;\r\n\r\n                const b = _inspect(globB);\r\n\r\n                // keep negated if:\r\n                //    1) any negated covers it\r\n                //    2) no positive covers it\r\n                // keep positive if:\r\n                //    1) no positive covers it OR any negated covers it\r\n\r\n                notCovered = !_covers(b, a);\r\n                if (notCovered) {\r\n                    if (a.isNegated && b.isNegated) {\r\n                        const inter = _intersect(a.glob, b.glob, restrictive);\r\n                        if (inter && union.indexOf(inter) === -1) intersections.push(inter);\r\n                    }\r\n                    return; // next\r\n                }\r\n\r\n                if (a.isNegated) {\r\n                    if (b.isNegated) {\r\n                        negCoversNeg = !hasExact;\r\n                    } else {\r\n                        posCoversNeg = true; // set flag\r\n                    }\r\n                } else {\r\n                    if (!b.isNegated) {\r\n                        posCoversPos = !hasExact;\r\n                    } else {\r\n                        negCoversPos = true; // set flag\r\n                    }\r\n                }\r\n\r\n            });\r\n\r\n\r\n            const keep = a.isNegated\r\n                ? (!posCoversNeg || negCoversNeg)\r\n                : (!posCoversPos || negCoversPos);\r\n\r\n            if (hasExact || keep || (notCovered && !a.isNegated)) {\r\n                union.push(a.glob); // push normalized glob\r\n                return;\r\n            }\r\n\r\n            if (a.isNegated && posCoversNeg && !negCoversNeg && intersections.length > 0) {\r\n                union = union.concat(intersections);\r\n            }\r\n\r\n        });\r\n\r\n        return union;\r\n    }\r\n\r\n    /**\r\n     *  Gets the union from the given couple of glob arrays and returns a new\r\n     *  array of globs.\r\n     *  <ul>\r\n     *  <li>If the exact same element is found in both\r\n     *  arrays, one of them is removed to prevent duplicates.\r\n     *  <br />example: `['!id', 'name'] ∪ ['!id']` unites to `['!id', 'name']`</li>\r\n     *  <li>If any non-negated item is covered by a glob in the same\r\n     *  or other array, the redundant item is removed.\r\n     *  <br />example: `['*', 'name'] ∪ ['email']` unites to `['*']`</li>\r\n     *  <li>If one of the arrays contains a negated equivalent of an\r\n     *  item in the other array, the negated item is removed.\r\n     *  <br />example: `['!id'] ∪ ['id']` unites to `['id']`</li>\r\n     *  <li>If any item covers/matches a negated item in the other array,\r\n     *  the negated item is removed.\r\n     *  <br />example #1: `['!user.id'] ∪ ['user.*']` unites to `['user']`\r\n     *  <br />example #2: `['*'] ∪ ['!password']` unites to `['*']`\r\n     *  </li>\r\n     *  </ul>\r\n     *  @name Notation.Glob.union\r\n     *  @function\r\n     *\r\n     *  @param {Array} globsA - First array of glob strings.\r\n     *  @param {Array} globsB - Second array of glob strings.\r\n     *  @param {Boolean} [restrictive=false] - Whether negated items in each of\r\n     *  the lists, strictly remove every match in themselves (not the cross\r\n     *  list). This option is used when pre-normalizing each glob list and\r\n     *  normalizing the final union list.\r\n     *\r\n     *  @returns {Array} -\r\n     *\r\n     *  @example\r\n     *  const a = ['user.*', '!user.email', 'car.model', '!*.id'];\r\n     *  const b = ['!*.date', 'user.email', 'car', '*.age'];\r\n     *  const { union } = Notation.Glob;\r\n     *  union(a, b)     // ['car', 'user', '*.age', '!car.date', '!user.id']\r\n     */\r\n    static union(globsA, globsB, restrictive) {\r\n        const { normalize, _compareUnion } = Glob;\r\n\r\n        const listA = normalize(globsA, restrictive);\r\n        const listB = normalize(globsB, restrictive);\r\n\r\n        if (listA.length === 0) return listB;\r\n        if (listB.length === 0) return listA;\r\n\r\n        // TODO: below should be optimized\r\n        let union = _compareUnion(listA, listB, restrictive);\r\n        union = _compareUnion(listB, listA, restrictive, union);\r\n        return normalize(union, restrictive);\r\n    }\r\n\r\n}\r\n\r\n// --------------------------------\r\n// HELPERS\r\n// --------------------------------\r\n\r\n// used by static _covers\r\nfunction _coversNote(a, b) {\r\n    if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\r\n    const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\r\n    // obj-wildcard a will cover b if not array\r\n    if (a === '*') return !bIsArr;\r\n    // arr-wildcard a will cover b if array\r\n    if (a === '[*]') return bIsArr;\r\n    // seems, a is not wildcard so,\r\n    // if b is wildcard (obj or arr) won't be covered\r\n    if (re.WILDCARD.test(b)) return false;\r\n    // normalize both and check for equality\r\n    // e.g. x.y and x['y'] are the same\r\n    return utils.normalizeNote(a) === utils.normalizeNote(b);\r\n}\r\n// function _coversNote(a, b) {\r\n//     if (!a || !b) return false; // glob e.g.: [2] does not cover [2][1]\r\n//     a = utils.normalizeNote(a, true);\r\n//     b = utils.normalizeNote(b, true);\r\n//     if (a === b) return true;\r\n//     const bIsArr = re.ARRAY_GLOB_NOTE.test(b);\r\n//     return (a === '*' && !bIsArr) || (a === '[*]' && bIsArr);\r\n// }\r\n// used by static _covers\r\nfunction _matchesNote(a, b) {\r\n    if (!a || !b) return true; // glob e.g.: [2][1] matches [2] and vice-versa.\r\n    return _coversNote(a, b) || _coversNote(b, a);\r\n}\r\n\r\n// used by _compareArrayItemGlobs() for getting a numeric index from array note.\r\n// we'll use these indexes to sort higher to lower, as removing order; to\r\n// prevent shifted indexes.\r\nfunction _idxVal(note) {\r\n    // we return -1 for wildcard bec. we need it to come last\r\n\r\n    // below will never execute when called from _compareArrayItemGlobs\r\n    /* istanbul ignore next */\r\n    // if (note === '[*]') return -1;\r\n\r\n    // e.g. '[2]' » 2\r\n    return parseInt(note.replace(/[[\\]]/, ''), 10);\r\n}\r\n\r\nfunction _compArrIdx(lastA, lastB) {\r\n    const iA = _idxVal(lastA);\r\n    const iB = _idxVal(lastB);\r\n\r\n    // below will never execute when called from _compareArrayItemGlobs\r\n    /* istanbul ignore next */\r\n    // if (iA === iB) return 0;\r\n\r\n    return iA > iB ? -1 : 1;\r\n}\r\n\r\n// when we remove items from an array (via e.g. filtering), we first need to\r\n// remove the item with the greater index so indexes of other items (that are to\r\n// be removed from the same array) do not shift. so below is for comparing 2\r\n// globs if they represent 2 items from the same array.\r\n\r\n// example items from same array: ![*][2] ![0][*] ![0][1] ![0][3]\r\n// should be sorted as ![0][3] ![*][2] ![0][1] ![0][*]\r\nfunction _compareArrayItemGlobs(a, b) {\r\n    const reANote = re.ARRAY_GLOB_NOTE;\r\n    // both should be negated\r\n    if (!a.isNegated\r\n            || !b.isNegated\r\n            // should be same length (since we're comparing for items in same\r\n            // array)\r\n            || a.notes.length !== b.notes.length\r\n            // last notes should be array brackets\r\n            || !reANote.test(a.last)\r\n            || !reANote.test(b.last)\r\n            // last notes should be different to compare\r\n            || a.last === b.last\r\n    ) return 0;\r\n\r\n    // negated !..[*] should come last\r\n    if (a.last === '[*]') return 1; // b is first\r\n    if (b.last === '[*]') return -1; // a is first\r\n\r\n    if (a.parent && b.parent) {\r\n        const { _covers } = Glob;\r\n        if (_covers(a.parent, b.parent, true)) {\r\n            return _compArrIdx(a.last, b.last);\r\n        }\r\n        return 0;\r\n    }\r\n    return _compArrIdx(a.last, b.last);\r\n}\r\n\r\n// x vs !x.*.*      » false\r\n// x vs !x[*]       » true\r\n// x[*] vs !x       » true\r\n// x[*] vs !x[*]    » false\r\n// x.* vs !x.*      » false\r\nfunction _isReverseOf(a, b) {\r\n    return a.isNegated !== b.isNegated\r\n        && a.absGlob === b.absGlob;\r\n}\r\n\r\nfunction _invert(glob) {\r\n    return glob[0] === '!' ? glob.slice(1) : '!' + glob;\r\n}\r\n\r\nconst _rx = /^\\s*!/;\r\nfunction _negFirstSort(a, b) {\r\n    const negA = _rx.test(a);\r\n    const negB = _rx.test(b);\r\n    if (negA && negB) return a.length >= b.length ? 1 : -1;\r\n    if (negA) return -1;\r\n    if (negB) return 1;\r\n    return 0;\r\n}\r\nfunction _negLastSort(a, b) {\r\n    const negA = _rx.test(a);\r\n    const negB = _rx.test(b);\r\n    if (negA && negB) return a.length >= b.length ? 1 : -1;\r\n    if (negA) return 1;\r\n    if (negB) return -1;\r\n    return 0;\r\n}\r\n\r\n// --------------------------------\r\n// EXPORT\r\n// --------------------------------\r\n\r\nexport { Glob };\r\n","/* eslint no-use-before-define:0, consistent-return:0, max-statements:0, max-len:0 */\r\n\r\nimport { Glob } from './notation.glob';\r\nimport { NotationError } from './notation.error';\r\nimport { utils } from '../utils';\r\n\r\nconst ERR = {\r\n    SOURCE: 'Invalid source. Expected a data object or array.',\r\n    DEST: 'Invalid destination. Expected a data object or array.',\r\n    NOTATION: 'Invalid notation: ',\r\n    NOTA_OBJ: 'Invalid notations object. ',\r\n    NO_INDEX: 'Implied index does not exist: ',\r\n    NO_PROP: 'Implied property does not exist: '\r\n};\r\n\r\n// created test @ https://regex101.com/r/vLE16M/2\r\nconst reMATCHER = /(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|[a-z$_][a-z$_\\d]*)/gi;\r\n// created test @ https://regex101.com/r/fL3PJt/1/\r\n// /^([a-z$_][a-z$_\\d]*|\\[(\\d+|\".*\"|'.*'|`.*`)\\])(\\[(\\d+|\".*\"|'.*'|`.*`)\\]|(\\.[a-z$_][a-z$_\\d]*))*$/i\r\nconst reVALIDATOR = new RegExp(\r\n    '^('\r\n    + '[a-z$_][a-z$_\\\\d]*'          // JS variable syntax\r\n    + '|'                           // OR\r\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // array index or object bracket notation\r\n    + ')'                           // exactly once\r\n    + '('\r\n    + '\\\\[(\\\\d+|\".*\"|\\'.*\\')\\\\]'    // followed by same\r\n    + '|'                           // OR\r\n    + '\\\\.[a-z$_][a-z$_\\\\d]*'       // dot, then JS variable syntax\r\n    + ')*'                          // (both) may repeat any number of times\r\n    + '$'\r\n    , 'i'\r\n);\r\n\r\nconst DEFAULT_OPTS = Object.freeze({\r\n    strict: false,\r\n    preserveIndices: false\r\n});\r\n\r\n/**\r\n *  Notation.js for Node and Browser.\r\n *\r\n *  Like in most programming languages, JavaScript makes use of dot-notation to\r\n *  access the value of a member of an object (or class). `Notation` class\r\n *  provides various methods for modifying / processing the contents of the\r\n *  given object; by parsing object notation strings or globs.\r\n *\r\n *  Note that this class will only deal with enumerable properties of the source\r\n *  object; so it should be used to manipulate data objects. It will not deal\r\n *  with preserving the prototype-chain of the given object.\r\n *\r\n *  @author   Onur Yıldırım <onur@cutepilot.com>\r\n *  @license  MIT\r\n */\r\nclass Notation {\r\n\r\n    /**\r\n     *  Initializes a new instance of `Notation`.\r\n     *\r\n     *  @param {Object|Array} [source={}] - The source object (or array) to be\r\n     *  notated. Can either be an array or object. If omitted, defaults to an\r\n     *  empty object.\r\n     *  @param {Object} [options] - Notation options.\r\n     *      @param {Boolean} [options.strict=false] - Whether to throw either when\r\n     *      a notation path does not exist on the source (i.e. `#get()` and `#remove()`\r\n     *      methods); or notation path exists but overwriting is disabled (i.e.\r\n     *      `#set()` method). (Note that `.inspectGet()` and `.inspectRemove()` methods\r\n     *      are exceptions). It's recommended to set this to `true` and prevent silent\r\n     *      failures if you're working with sensitive data. Regardless of `strict` option,\r\n     *      it will always throw on invalid notation syntax or other crucial failures.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = new Notation(obj);\r\n     *  notation.get('car.model')   // » \"Charger\"\r\n     *  notation.remove('car.model').set('car.color', 'red').value\r\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\r\n     */\r\n    constructor(source, options) {\r\n        if (arguments.length === 0) {\r\n            this._source = {};\r\n        } else if (!utils.isCollection(source)) {\r\n            throw new NotationError(ERR.SOURCE);\r\n        } else {\r\n            this._source = source;\r\n        }\r\n\r\n        this._isArray = utils.type(this._source) === 'array';\r\n        this.options = options;\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE PROPERTIES\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Gets or sets notation options.\r\n     *  @type {Object}\r\n     */\r\n    get options() {\r\n        return this._options;\r\n    }\r\n\r\n    set options(value) {\r\n        this._options = {\r\n            ...DEFAULT_OPTS,\r\n            ...(this._options || {}),\r\n            ...(value || {})\r\n        };\r\n    }\r\n\r\n    /**\r\n     *  Gets the value of the source object.\r\n     *  @type {Object|Array}\r\n     *\r\n     *  @example\r\n     *  const person = { name: \"Onur\" };\r\n     *  const me = Notation.create(person)\r\n     *      .set(\"age\", 36)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .value;\r\n     *  console.log(me); // { name: \"Onur\", age: 36, car: { brand: \"Ford\", model: \"Mustang\" } }\r\n     *  console.log(person === me); // true\r\n     */\r\n    get value() {\r\n        return this._source;\r\n    }\r\n\r\n    // --------------------------------\r\n    // INSTANCE METHODS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Recursively iterates through each key of the source object and invokes\r\n     *  the given callback function with parameters, on each non-object value.\r\n     *\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each on each non-object value. To break out of the loop, return `false`\r\n     *  from within the callback.\r\n     *  Callback signature: `callback(notation, key, value, object) { ... }`\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj).each(function (notation, key, value, object) {\r\n     *      console.log(notation, value);\r\n     *  });\r\n     *  // \"car.brand\"  \"Dodge\"\r\n     *  // \"car.model\"  \"Charger\"\r\n     *  // \"car.year\"  1970\r\n     */\r\n    each(callback) {\r\n        _each(this._source, callback);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note of the given notation string by evaluating\r\n     *  it on the source object.\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within\r\n     *  the callback. Signature: `callback(levelValue, note, index, list)`\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .eachValue(\"car.brand\", function (levelValue, note, index, list) {\r\n     *          console.log(note, levelValue); // \"car.brand\" \"Dodge\"\r\n     *      });\r\n     */\r\n    eachValue(notation, callback) {\r\n        let level = this._source;\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            level = utils.hasOwn(level, note) ? level[note] : undefined;\r\n            if (callback(level, levelNotation, note, index, list) === false) return false;\r\n\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Gets the list of notations from the source object (keys).\r\n     *\r\n     *  @returns {Array} - An array of notation strings.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notations = Notation.create(obj).getNotations();\r\n     *  console.log(notations); // [ \"car.brand\", \"car.model\", \"car.year\" ]\r\n     */\r\n    getNotations() {\r\n        const list = [];\r\n        this.each(notation => {\r\n            list.push(notation);\r\n        });\r\n        return list;\r\n    }\r\n\r\n    /**\r\n     *  Deeply clones the source object. This is also useful if you want to\r\n     *  prevent mutating the original source object.\r\n     *\r\n     *  <blockquote>\r\n     *  Note that `Notation` expects a data object (or array) with enumerable\r\n     *  properties. In addition to plain objects and arrays; supported cloneable\r\n     *  property/value types are primitives (such as `String`, `Number`,\r\n     *  `Boolean`, `Symbol`, `null` and `undefined`) and built-in types (such as\r\n     *  `Date` and `RegExp`).\r\n     *\r\n     *  Enumerable properties with types other than these (such as methods,\r\n     *  special objects, custom class instances, etc) will be copied by reference.\r\n     *  Non-enumerable properties will not be cloned.\r\n     *\r\n     *  If you still need full clone support, you can use a library like lodash.\r\n     *  e.g. `Notation.create(_.cloneDeep(source))`\r\n     *  </blockquote>\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const mutated = Notation.create(source1).set('newProp', true).value;\r\n     *  console.log(source1.newProp); // ——» true\r\n     *\r\n     *  const cloned = Notation.create(source2).clone().set('newProp', true).value;\r\n     *  console.log('newProp' in source2); // ——» false\r\n     *  console.log(cloned.newProp); // ——» true\r\n     */\r\n    clone() {\r\n        this._source = utils.cloneDeep(this._source);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Flattens the source object to a single-level object with notated keys.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  console.log(Notation.create(obj).flatten().value);\r\n     *  // {\r\n     *  //     \"car.brand\": \"Dodge\",\r\n     *  //     \"car.model\": \"Charger\",\r\n     *  //     \"car.year\": 1970\r\n     *  // }\r\n     */\r\n    flatten() {\r\n        const o = {};\r\n        this.each((notation, key, value) => {\r\n            o[notation] = value;\r\n        });\r\n        this._source = o;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Aggregates notated keys of a (single-level) object, and nests them under\r\n     *  their corresponding properties. This is the opposite of `Notation#flatten`\r\n     *  method. This might be useful when expanding a flat object fetched from\r\n     *  a database.\r\n     *  @alias Notation#aggregate\r\n     *  @chainable\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { \"car.brand\": \"Dodge\", \"car.model\": \"Charger\", \"car.year\": 1970 }\r\n     *  const expanded = Notation.create(obj).expand().value;\r\n     *  console.log(expanded); // { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     */\r\n    expand() {\r\n        this._source = Notation.create({}).merge(this._source).value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#expand`\r\n     *  @private\r\n     *  @returns {Notation} -\r\n     */\r\n    aggregate() {\r\n        return this.expand();\r\n    }\r\n\r\n    /**\r\n     *  Inspects the given notation on the source object by checking\r\n     *  if the source object actually has the notated property;\r\n     *  and getting its value if exists.\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.year\");\r\n     *  // { has: true, value: 1970, lastNote: 'year', lastNoteNormalized: 'year' }\r\n     *  Notation.create({ car: { year: 1970 } }).inspectGet(\"car.color\");\r\n     *  // { has: false }\r\n     *  Notation.create({ car: { color: undefined } }).inspectGet(\"car.color\");\r\n     *  // { has: true, value: undefined, lastNote: 'color', lastNoteNormalized: 'color' }\r\n     *  Notation.create({ car: { brands: ['Ford', 'Dodge'] } }).inspectGet(\"car.brands[1]\");\r\n     *  // { has: true, value: 'Dodge', lastNote: '[1]', lastNoteNormalized: 1 }\r\n     */\r\n    inspectGet(notation) {\r\n        let level = this._source;\r\n        let result = { has: false, value: undefined };\r\n        let parent;\r\n        Notation.eachNote(notation, (levelNotation, note, index) => {\r\n            const lastNoteNormalized = utils.normalizeNote(note);\r\n            if (utils.hasOwn(level, lastNoteNormalized)) {\r\n                level = level[lastNoteNormalized];\r\n                parent = level;\r\n                result = {\r\n                    notation,\r\n                    has: true,\r\n                    value: level,\r\n                    type: utils.type(level),\r\n                    level: index + 1,\r\n                    lastNote: note,\r\n                    lastNoteNormalized\r\n                };\r\n            } else {\r\n                // level = undefined;\r\n                result = {\r\n                    notation,\r\n                    has: false,\r\n                    type: 'undefined',\r\n                    level: index + 1,\r\n                    lastNote: note,\r\n                    lastNoteNormalized\r\n                };\r\n                return false; // break out\r\n            }\r\n        });\r\n\r\n        if (parent === undefined || (result.has && parent === result.value)) parent = this._source;\r\n        result.parentIsArray = utils.type(parent) === 'array';\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Notation inspection result object.\r\n     *  @typedef Notation~InspectResult\r\n     *  @type Object\r\n     *  @property {String} notation - Notation that is inspected.\r\n     *  @property {Boolean} has - Indicates whether the source object has the\r\n     *  given notation as a (leveled) enumerable property. If the property\r\n     *  exists but has a value of `undefined`, this will still return `true`.\r\n     *  @property {*} value - The value of the notated property. If the source\r\n     *  object does not have the notation, the value will be `undefined`.\r\n     *  @property {String} type - The type of the notated property. If the source\r\n     *  object does not have the notation, the type will be `\"undefined\"`.\r\n     *  @property {String} lastNote - Last note of the notation, if actually\r\n     *  exists. For example, last note of `'a.b.c'` is `'c'`.\r\n     *  @property {String|Number} lastNoteNormalized - Normalized representation\r\n     *  of the last note of the notation, if actually exists. For example, last\r\n     *  note of `'a.b[1]` is `'[1]'` and will be normalized to number `1`; which\r\n     *  indicates an array index.\r\n     *  @property {Boolean} parentIsArray - Whether the parent object of the\r\n     *  notation path is an array.\r\n     */\r\n\r\n    /**\r\n     *  Inspects and removes the given notation from the source object by\r\n     *  checking if the source object actually has the notated property; and\r\n     *  getting its value if exists, before removing the property.\r\n     *\r\n     *  @param {String} notation - The notation string to be inspected.\r\n     *\r\n     *  @returns {InspectResult} - The result object.\r\n     *\r\n     *  @example\r\n     *  const obj = { name: \"John\", car: { year: 1970 } };\r\n     *  let result = Notation.create(obj).inspectRemove(\"car.year\");\r\n     *  // result » { notation: \"car.year\", has: true, value: 1970, lastNote: \"year\", lastNoteNormalized: \"year\" }\r\n     *  // obj » { name: \"John\", car: {} }\r\n     *\r\n     *  result = Notation.create({ car: { year: 1970 } }).inspectRemove(\"car.color\");\r\n     *  // result » { notation: \"car.color\", has: false }\r\n     *  Notation.create({ car: { color: undefined } }).inspectRemove(\"car['color']\");\r\n     *  // { notation: \"car.color\", has: true, value: undefined, lastNote: \"['color']\", lastNoteNormalized: \"color\" }\r\n     *\r\n     *  const obj = { car: { colors: [\"black\", \"white\"] } };\r\n     *  const result = Notation.create().inspectRemove(\"car.colors[0]\");\r\n     *  // result » { notation: \"car.colors[0]\", has: true, value: \"black\", lastNote: \"[0]\", lastNoteNormalized: 0 }\r\n     *  // obj » { car: { colors: [(empty), \"white\"] } }\r\n     */\r\n    inspectRemove(notation) {\r\n        if (!notation) throw new Error(ERR.NOTATION + `'${notation}'`);\r\n        const parentNotation = Notation.parent(notation);\r\n        const parent = parentNotation ? this.get(parentNotation, null) : this._source;\r\n        const parentIsArray = utils.type(parent) === 'array';\r\n        const notes = Notation.split(notation);\r\n        const lastNote = notes[notes.length - 1];\r\n        const lastNoteNormalized = utils.normalizeNote(lastNote);\r\n\r\n        let result, value;\r\n        if (utils.hasOwn(parent, lastNoteNormalized)) {\r\n            value = parent[lastNoteNormalized];\r\n            result = {\r\n                notation,\r\n                has: true,\r\n                value,\r\n                type: utils.type(value),\r\n                level: notes.length,\r\n                lastNote,\r\n                lastNoteNormalized,\r\n                parentIsArray\r\n            };\r\n\r\n            // if `preserveIndices` is enabled and this is an array, we'll\r\n            // splice the item out. otherwise, we'll use `delete` syntax to\r\n            // empty the item.\r\n            if (!this.options.preserveIndices && parentIsArray) {\r\n                parent.splice(lastNoteNormalized, 1);\r\n            } else {\r\n                delete parent[lastNoteNormalized];\r\n            }\r\n        } else {\r\n            result = {\r\n                notation,\r\n                has: false,\r\n                type: 'undefined',\r\n                level: notes.length,\r\n                lastNote,\r\n                lastNoteNormalized,\r\n                parentIsArray\r\n            };\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) enumerable property. If the property exists\r\n     *  but has a value of `undefined`, this will still return `true`.\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).has(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).has(\"car.year\"); // true\r\n     *  Notation.create({}).has(\"car.color\"); // false\r\n     */\r\n    has(notation) {\r\n        return this.inspectGet(notation).has;\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the source object has the given notation\r\n     *  as a (leveled) defined enumerable property. If the property\r\n     *  exists but has a value of `undefined`, this will return `false`.\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { year: 1970 } }).hasDefined(\"car.year\"); // true\r\n     *  Notation.create({ car: { year: undefined } }).hasDefined(\"car.year\"); // false\r\n     *  Notation.create({}).hasDefined(\"car.color\"); // false\r\n     */\r\n    hasDefined(notation) {\r\n        return this.inspectGet(notation).value !== undefined;\r\n    }\r\n\r\n    /**\r\n     *  Gets the value of the corresponding property at the given notation.\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {String} [defaultValue] - The default value to be returned if the\r\n     *  property is not found or enumerable.\r\n     *\r\n     *  @returns {*} - The value of the notated property.\r\n     *  @throws {NotationError} - If `strict` option is enabled, `defaultValue`\r\n     *  is not set and notation does not exist.\r\n     *\r\n     *  @example\r\n     *  Notation.create({ car: { brand: \"Dodge\" } }).get(\"car.brand\"); // \"Dodge\"\r\n     *  Notation.create({ car: {} }).get(\"car.model\", \"Challenger\"); // \"Challenger\"\r\n     *  Notation.create({ car: { model: undefined } }).get(\"car.model\", \"Challenger\"); // undefined\r\n     *\r\n     *  @example <caption>get value when strict option is enabled</caption>\r\n     *  // strict option defaults to false\r\n     *  Notation.create({ car: {} }).get(\"car.model\"); // undefined\r\n     *  Notation.create({ car: {} }, { strict: false }).get(\"car.model\"); // undefined\r\n     *  // below will throw bec. strict = true, car.model does not exist\r\n     *  // and no default value is given.\r\n     *  Notation.create({ car: {} }, { strict: true }).get(\"car.model\");\r\n     */\r\n    get(notation, defaultValue) {\r\n        const result = this.inspectGet(notation);\r\n        // if strict and no default value is set, check if implied index or prop\r\n        // exists\r\n        if (this.options.strict && arguments.length < 2 && !result.has) {\r\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\r\n            throw new NotationError(msg + `'${notation}'`);\r\n        }\r\n        return result.has ? result.value : defaultValue;\r\n    }\r\n\r\n    /**\r\n     *  Sets the value of the corresponding property at the given notation. If\r\n     *  the property does not exist, it will be created and nested at the\r\n     *  calculated level. If it exists; its value will be overwritten by\r\n     *  default.\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @param {*} value - The value to be set for the notated property.\r\n     *  @param {String|Boolean} [mode=\"overwrite\"] - Write mode. By default,\r\n     *  this is set to `\"overwrite\"` which sets the value by overwriting the\r\n     *  target object property or array item at index. To insert an array item\r\n     *  (by shifting the index, instead of overwriting); set to `\"insert\"`. To\r\n     *  prevent overwriting the value if exists, explicitly set to `false`.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If strict notation is enabled, `overwrite`\r\n     *  option is set to `false` and attempted to overwrite an existing value.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj)\r\n     *      .set(\"car.brand\", \"Ford\")\r\n     *      .set(\"car.model\", \"Mustang\")\r\n     *      .set(\"car.year\", 1965, false)\r\n     *      .set(\"car.color\", \"red\")\r\n     *      .set(\"boat\", \"none\");\r\n     *  console.log(obj);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    set(notation, value, mode = 'overwrite') {\r\n        if (!notation.trim()) throw new NotationError(ERR.NOTATION + `'${notation}'`);\r\n        if (mode === true) mode = 'overwrite';\r\n        let level = this._source;\r\n        let currentIsLast, nCurrentNote, nNextNote, nextIsArrayNote, type;\r\n        const insertErrMsg = 'Cannot set value by inserting at index, on an object';\r\n\r\n        Notation.eachNote(notation, (levelNotation, note, index, list) => {\r\n            currentIsLast = index === list.length - 1;\r\n            nCurrentNote = nNextNote || utils.normalizeNote(note);\r\n            nNextNote = currentIsLast ? null : utils.normalizeNote(list[index + 1]);\r\n            type = utils.type(level);\r\n\r\n            if (type === 'array' && typeof nCurrentNote !== 'number') {\r\n                const parent = Notation.parent(levelNotation) || 'source';\r\n                throw new NotationError(`Cannot set string key '${note}' on array ${parent}`);\r\n            }\r\n\r\n            // check if the property is at this level\r\n            if (utils.hasOwn(level, nCurrentNote, type)) {\r\n                // check if we're at the last level\r\n                if (currentIsLast) {\r\n                    // if mode is \"overwrite\", assign the value.\r\n                    if (mode === 'overwrite') {\r\n                        level[nCurrentNote] = value;\r\n                    } else if (mode === 'insert') {\r\n                        if (type === 'array') {\r\n                            level.splice(nCurrentNote, 0, value);\r\n                        } else {\r\n                            throw new NotationError(insertErrMsg);\r\n                        }\r\n                    }\r\n                    // otherwise, will not overwrite\r\n                } else {\r\n                    // if not last level; just re-reference the current level.\r\n                    level = level[nCurrentNote];\r\n                }\r\n            } else {\r\n                if (currentIsLast && type !== 'array' && mode === 'insert') {\r\n                    throw new NotationError(insertErrMsg);\r\n                }\r\n\r\n                // if next normalized note is a number, it indicates that the\r\n                // current note is actually an array.\r\n                nextIsArrayNote = typeof nNextNote === 'number';\r\n\r\n                // we don't have this property at this level so; if this is the\r\n                // last level, we set the value if not, we set an empty\r\n                // collection for the next level\r\n                level[nCurrentNote] = (currentIsLast ? value : (nextIsArrayNote ? [] : {}));\r\n                level = level[nCurrentNote];\r\n            }\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Just like the `.set()` method but instead of a single notation\r\n     *  string, an object of notations and values can be passed.\r\n     *  Sets the value of each corresponding property at the given\r\n     *  notation. If a property does not exist, it will be created\r\n     *  and nested at the calculated level. If it exists; its value\r\n     *  will be overwritten by default.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object} notationsObject - The notations object to be processed.\r\n     *  This can either be a regular object with non-dotted keys\r\n     *  (which will be merged to the first/root level of the source object);\r\n     *  or a flattened object with notated (dotted) keys.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite a property if\r\n     *  exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 } };\r\n     *  Notation.create(obj).merge({\r\n     *      \"car.brand\": \"Ford\",\r\n     *      \"car.model\": \"Mustang\",\r\n     *      \"car.year\": 1965,\r\n     *      \"car.color\": \"red\",\r\n     *      \"boat\": \"none\"\r\n     *  });\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Mustang\", year: 1970, color: \"red\" }, boat: \"none\" };\r\n     */\r\n    merge(notationsObject, overwrite = true) {\r\n        if (utils.type(notationsObject) !== 'object') {\r\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an object.');\r\n        }\r\n        let value;\r\n        utils.each(Object.keys(notationsObject), notation => {\r\n            value = notationsObject[notation];\r\n            this.set(notation, value, overwrite);\r\n        });\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the properties by the given list of notations from the source\r\n     *  object and returns a new object with the removed properties.\r\n     *  Opposite of `merge()` method.\r\n     *\r\n     *  @param {Array} notations - The notations array to be processed.\r\n     *\r\n     *  @returns {Object} - An object with the removed properties.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", year: 1970 }, notebook: \"Mac\" };\r\n     *  const separated = Notation.create(obj).separate([\"car.brand\", \"boat\" ]);\r\n     *  console.log(separated);\r\n     *  // { notebook: \"Mac\", car: { brand: \"Ford\" } };\r\n     *  console.log(obj);\r\n     *  // { car: { year: 1970 } };\r\n     */\r\n    separate(notations) {\r\n        if (utils.type(notations) !== 'array') {\r\n            throw new NotationError(ERR.NOTA_OBJ + 'Expected an array.');\r\n        }\r\n        const o = new Notation({});\r\n        utils.each(notations, notation => {\r\n            const result = this.inspectRemove(notation);\r\n            o.set(notation, result.value);\r\n        });\r\n        this._source = o._source;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Deep clones the source object while filtering its properties by the\r\n     *  given <b>glob</b> notations. Includes all matched properties and removes\r\n     *  the rest.\r\n     *\r\n     *  The difference between regular notations and glob-notations is that;\r\n     *  with the latter, you can use wildcard stars (*) and negate the notation\r\n     *  by prepending a bang (!). A negated notation will be excluded.\r\n     *\r\n     *  Order of the globs does not matter; they will be logically sorted. Loose\r\n     *  globs will be processed first and verbose globs or normal notations will\r\n     *  be processed last. e.g. `[ \"car.model\", \"*\", \"!car.*\" ]` will be\r\n     *  normalized and sorted as `[ \"*\", \"!car\" ]`.\r\n     *\r\n     *  Passing no parameters or passing a glob of `\"!*\"` or `[\"!*\"]` will empty\r\n     *  the source object. See `Notation.Glob` class for more information.\r\n     *  @chainable\r\n     *\r\n     *  @param {Array|String} globList - Glob notation list to be processed.\r\n     *  @param {Object} [options] - Filter options.\r\n     *  @param {Boolean} [options.restrictive=false] - Whether negated items\r\n     *  strictly remove every match. Note that, regardless of this option, if\r\n     *  any item has an exact negated version; non-negated is always removed.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self). To get the\r\n     *  filtered value, call `.value` property on the instance.\r\n     *\r\n     *  @example\r\n     *  const car = { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } };\r\n     *  const n = Notation.create(car);\r\n     *\r\n     *  console.log(n.filter([ \"*\", \"!model.year\" ]).value);  // { brand: \"Ford\", model: { name: \"Mustang\" } }\r\n     *  console.log(n.filter(\"model.name\").value);            // { model: { name: \"Mustang\" } }\r\n     *  console.log(car);                                     // { brand: \"Ford\", model: { name: \"Mustang\", year: 1970 } }\r\n     *  console.log(n.filter().value);                        // {} // —» equivalent to n.filter(\"\") or n.filter(\"!*\")\r\n     */\r\n    filter(globList, options = {}) {\r\n        const { re } = utils;\r\n\r\n        // ensure array, normalize and sort the globs in logical order. this\r\n        // also concats the array first (to prevent mutating the original\r\n        // array).\r\n        const globs = Glob.normalize(globList, options.restrictive);\r\n        const len = globs.length;\r\n        const empty = this._isArray ? [] : {};\r\n\r\n        // if globs is \"\" or [\"\"] or [\"!*\"] or [\"![*]\"] set source to empty and return.\r\n        if (len === 0 || (len === 1 && (!globs[0] || re.NEGATE_ALL.test(globs[0])))) {\r\n            this._source = empty;\r\n            return this;\r\n        }\r\n\r\n        const cloned = utils.cloneDeep(this.value);\r\n\r\n        const firstIsWildcard = re.WILDCARD.test(globs[0]);\r\n        // if globs only consist of \"*\" or \"[*]\"; set the \"clone\" as source and\r\n        // return.\r\n        if (len === 1 && firstIsWildcard) {\r\n            this._source = cloned;\r\n            return this;\r\n        }\r\n\r\n        let filtered;\r\n        // if the first item of sorted globs is \"*\" or \"[*]\" we set the source\r\n        // to the (full) \"copy\" and remove the wildcard from globs (not to\r\n        // re-process).\r\n        if (firstIsWildcard) {\r\n            filtered = new Notation(cloned);\r\n            globs.shift();\r\n        } else {\r\n            // otherwise we set an empty object or array as the source so that\r\n            // we can add notations/properties to it.\r\n            filtered = new Notation(empty);\r\n        }\r\n\r\n        // iterate through globs\r\n        utils.each(globs, globNotation => {\r\n            // console.log('globNotation', globNotation);\r\n            const g = new Glob(globNotation);\r\n            const { glob, absGlob, isNegated, levels } = g;\r\n            let normalized, emptyValue, eType;\r\n            // check whether the glob ends with `.*` or `[*]` then remove\r\n            // trailing glob note and decide for empty value (if negated). for\r\n            // non-negated, trailing wildcards are already removed by\r\n            // normalization.\r\n            if (absGlob.slice(-2) === '.*') {\r\n                normalized = absGlob.slice(0, -2);\r\n                /* istanbul ignore else */\r\n                if (isNegated) emptyValue = {};\r\n                eType = 'object';\r\n            } else if (absGlob.slice(-3) === '[*]') {\r\n                normalized = absGlob.slice(0, -3);\r\n                /* istanbul ignore else */\r\n                if (isNegated) emptyValue = [];\r\n                eType = 'array';\r\n            } else {\r\n                normalized = absGlob;\r\n            }\r\n\r\n            // we'll check glob vs value integrity if emptyValue is set; and throw if needed.\r\n            const errGlobIntegrity = `Integrity failed for glob '${glob}'. Cannot set empty ${eType} for '${normalized}' which has a type of `; // ...\r\n\r\n            // check if remaining normalized glob has no wildcard stars e.g.\r\n            // \"a.b\" or \"!a.b.c\" etc..\r\n            if (re.WILDCARDS.test(normalized) === false) {\r\n                if (isNegated) {\r\n                    // inspect and directly remove the notation if negated.\r\n                    // we need the inspection for the detailed error below.\r\n                    const insRemove = filtered.inspectRemove(normalized);\r\n                    // console.log('insRemove', insRemove);\r\n\r\n                    // if original glob had `.*` at the end, it means remove\r\n                    // contents (not itself). so we'll set an empty object.\r\n                    // meaning `some.prop` (prop) is removed completely but\r\n                    // `some.prop.*` (prop) results in `{}`. For array notation\r\n                    // (`[*]`), we'll set an empty array.\r\n                    if (emptyValue) {\r\n                        // e.g. for glob `![0].x.*` we expect to set `[0].x = {}`\r\n                        // but if `.x` is not an object (or array), we should fail.\r\n                        const vType = insRemove.type;\r\n                        const errMsg = errGlobIntegrity + `'${vType}'.`;\r\n                        // in non-strict mode, only exceptions are `null` and\r\n                        // `undefined`, for which we won't throw but we'll not\r\n                        // set an empty obj/arr either.\r\n\r\n                        const isValSet = utils.isset(insRemove.value);\r\n                        // on critical type mismatch we throw\r\n                        // or if original value is undefined or null in strict mode we throw\r\n                        if ((isValSet && vType !== eType) || (!isValSet && this.options.strict)) {\r\n                            throw new NotationError(errMsg);\r\n                        }\r\n                        // if parent is an array, we'll insert the value at\r\n                        // index bec. we've removed the item and indexes are\r\n                        // shifted. Otherwise, we'll simply overwrite the\r\n                        // object property value.\r\n                        const setMode = insRemove.parentIsArray ? 'insert' : 'overwrite';\r\n                        // console.log('setting', normalized, emptyValue, setMode);\r\n                        filtered.set(normalized, emptyValue, setMode);\r\n                    }\r\n                } else {\r\n                    // directly set the same notation from the original\r\n                    const insGet = this.inspectGet(normalized); // Notation.create(original).inspectGet ...\r\n                    /* istanbul ignore else */\r\n                    if (insGet.has) filtered.set(normalized, insGet.value, 'overwrite');\r\n                }\r\n                // move to the next\r\n                return true;\r\n            }\r\n\r\n            // if glob has wildcard(s), we'll iterate through keys of the source\r\n            // object and see if (full) notation of each key matches the current\r\n            // glob.\r\n\r\n            // important! we will iterate with eachRight to prevent shifted\r\n            // indexes when removing items from arrays.\r\n            const reverseIterateIfArray = true;\r\n\r\n            _each(this._source, (originalNotation, key, value) => {\r\n                const originalIsCovered = Glob.create(normalized).covers(originalNotation);\r\n                // console.log('» normalized:', normalized, 'covers', originalNotation, '»', originalIsCovered);\r\n                if (!originalIsCovered) return true; // break\r\n\r\n                if (this.options.strict && emptyValue) {\r\n                    // since original is covered and we have emptyValue set (due\r\n                    // to trailing wildcard), here we'll check value vs glob\r\n                    // integrity; (only if we're in strict mode).\r\n\r\n                    const vType = utils.type(value);\r\n                    // types and number of levels are the same?\r\n                    if (vType !== eType\r\n                            // we subtract 1 from number of levels bec. the last\r\n                            // note is removed since we have emptyValue set.\r\n                            && Notation.split(originalNotation).length === levels.length - 1) {\r\n                        throw new NotationError(errGlobIntegrity + `'${vType}'.`);\r\n                    }\r\n                }\r\n\r\n                // iterating each note of original notation. i.e.:\r\n                // note1.note2.note3 is iterated from left to right, as:\r\n                // 'note1', 'note1.note2', 'note1.note2.note3' — in order.\r\n                Notation.eachNote(originalNotation, levelNotation => {\r\n                    // console.log('  level »', glob, 'covers', levelNotation, '»', g.test(levelNotation));\r\n\r\n                    if (g.test(levelNotation)) {\r\n                        const levelLen = Notation.split(levelNotation).length;\r\n                        /* istanbul ignore else */\r\n                        if (isNegated && levels.length <= levelLen) {\r\n                            // console.log('  » removing', levelNotation, 'of', originalNotation);\r\n                            filtered.remove(levelNotation);\r\n                            // we break and return early if removed bec. e.g.\r\n                            // when 'note1.note2' (parent) of\r\n                            // 'note1.note2.note3' is also removed, we no more\r\n                            // have 'note3'.\r\n                            return false;\r\n                        }\r\n                        // console.log('  » setting', levelNotation, '=', value);\r\n                        filtered.set(levelNotation, value, 'overwrite');\r\n                    }\r\n                });\r\n            }, reverseIterateIfArray);\r\n        });\r\n        // finally set the filtered's value as the source of our instance and\r\n        // return.\r\n        this._source = filtered.value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the property from the source object, at the given notation.\r\n     *  @alias Notation#delete\r\n     *  @chainable\r\n     *  @param {String} notation - The notation to be inspected.\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *  @throws {NotationError} - If `strict` option is enabled and notation\r\n     *  does not exist.\r\n     *\r\n     *  @example\r\n     *  const obj = { notebook: \"Mac\", car: { model: \"Mustang\" } };\r\n     *  Notation.create(obj).remove(\"car.model\");\r\n     *  console.log(obj); // { notebook: \"Mac\", car: { } }\r\n     */\r\n    remove(notation) {\r\n        const result = this.inspectRemove(notation);\r\n        // if strict, check if implied index or prop exists\r\n        if (this.options.strict && !result.has) {\r\n            const msg = result.parentIsArray ? ERR.NO_INDEX : ERR.NO_PROP;\r\n            throw new NotationError(msg + `'${notation}'`);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation#remove`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @returns {Notation} -\r\n     */\r\n    delete(notation) {\r\n        this.remove(notation);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the source collection and adds it to the\r\n     *  destination — only if the source object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} destination - The destination object that the notated\r\n     *  properties will be copied to.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source property\r\n     *  on the destination object. In other words, the copied property will be\r\n     *  renamed to this value before set on the destination object. If not set,\r\n     *  `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `destination` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyTo(models, \"car.model\", \"ford\");\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     *  // source object (obj) is not modified\r\n     */\r\n    copyTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\r\n        const result = this.inspectGet(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            Notation.create(destination).set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Copies the notated property from the target collection and adds it to\r\n     *  (own) source object — only if the target object actually has that\r\n     *  property. This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} target - The target collection that the notated\r\n     *  properties will be copied from.\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property from the target object.\r\n     *  @param {String} [newNotation=null] - The notation to set the copied\r\n     *  property on our source collection. In other words, the copied property\r\n     *  will be renamed to this value before set. If not set, `notation`\r\n     *  argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  our collection if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `target` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).copyFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  // models object is not modified\r\n     */\r\n    copyFrom(target, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\r\n        const result = Notation.create(target).inspectGet(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            this.set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the source (own) collection and adds\r\n     *  it to the destination — only if the source collection actually has that\r\n     *  property. This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} destination - The destination collection that the\r\n     *  notated properties will be moved to.\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property from the source object.\r\n     *  @param {String} [newNotation=null] - The notation to set the source\r\n     *  property on the destination object. In other words, the moved property\r\n     *  will be renamed to this value before set on the destination object. If\r\n     *  not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the destination object if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `destination` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveTo(models, \"car.model\", \"ford\");\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\" } }\r\n     *  console.log(models);\r\n     *  // { dodge: \"Charger\", ford: \"Mustang\" }\r\n     */\r\n    moveTo(destination, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(destination)) throw new NotationError(ERR.DEST);\r\n        const result = this.inspectRemove(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            Notation.create(destination).set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Removes the notated property from the target collection and adds it to (own)\r\n     *  source collection — only if the target object actually has that property.\r\n     *  This is different than a property with a value of `undefined`.\r\n     *  @chainable\r\n     *\r\n     *  @param {Object|Array} target - The target collection that the notated\r\n     *  properties will be moved from.\r\n     *  @param {String} notation - The notation to get the corresponding property\r\n     *  from the target object.\r\n     *  @param {String} [newNotation=null] - The notation to set the target\r\n     *  property on the source object. In other words, the moved property\r\n     *  will be renamed to this value before set on the source object.\r\n     *  If not set, `notation` argument will be used.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property on\r\n     *  the source object if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `target` is not a valid collection.\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const models = { dodge: \"Charger\" };\r\n     *  Notation.create(obj).moveFrom(models, \"dodge\", \"car.model\", true);\r\n     *  console.log(obj);\r\n     *  // { car: { brand: \"Ford\", model: \"Charger\" } }\r\n     *  console.log(models);\r\n     *  // {}\r\n     */\r\n    moveFrom(target, notation, newNotation = null, overwrite = true) {\r\n        if (!utils.isCollection(target)) throw new NotationError(ERR.DEST);\r\n        const result = Notation.create(target).inspectRemove(notation);\r\n        if (result.has) {\r\n            const newN = utils.getNewNotation(newNotation, notation);\r\n            this.set(newN, result.value, overwrite);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     *  Renames the notated property of the source collection by the new notation.\r\n     *  @alias Notation#renote\r\n     *  @chainable\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source collection.\r\n     *  @param {String} newNotation - The new notation for the targeted\r\n     *  property value. If not set, the source collection will not be modified.\r\n     *  @param {Boolean} [overwrite=true] - Whether to overwrite the property at\r\n     *  the new notation, if it exists.\r\n     *\r\n     *  @returns {Notation} - The current `Notation` instance (self).\r\n     *\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  Notation.create(obj)\r\n     *      .rename(\"car.brand\", \"carBrand\")\r\n     *      .rename(\"car.model\", \"carModel\");\r\n     *  console.log(obj);\r\n     *  // { carBrand: \"Ford\", carModel: \"Mustang\" }\r\n     */\r\n    rename(notation, newNotation, overwrite) {\r\n        return this.moveTo(this._source, notation, newNotation, overwrite);\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#rename`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {String} newNotation -\r\n     *  @param {Boolean} [overwrite=true] -\r\n     *  @returns {Notation} -\r\n     */\r\n    renote(notation, newNotation, overwrite) {\r\n        return this.rename(notation, newNotation, overwrite);\r\n    }\r\n\r\n    /**\r\n     *  Extracts the property at the given notation to a new object by copying\r\n     *  it from the source collection. This is equivalent to `.copyTo({},\r\n     *  notation, newNotation)`.\r\n     *  @alias Notation#copyToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @throws {NotationError} - If `notation` or `newNotation` is invalid.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extracted = Notation.create(obj).extract(\"car.brand\", \"carBrand\");\r\n     *  console.log(extracted);\r\n     *  // { carBrand: \"Ford\" }\r\n     *  // obj is not modified\r\n     */\r\n    extract(notation, newNotation) {\r\n        const o = {};\r\n        this.copyTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#extract`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {String} newNotation -\r\n     *  @returns {Object} -\r\n     */\r\n    copyToNew(notation, newNotation) {\r\n        return this.extract(notation, newNotation);\r\n    }\r\n\r\n    /**\r\n     *  Extrudes the property at the given notation to a new collection by\r\n     *  moving it from the source collection. This is equivalent to `.moveTo({},\r\n     *  notation, newNotation)`.\r\n     *  @alias Notation#moveToNew\r\n     *\r\n     *  @param {String} notation - The notation to get the corresponding\r\n     *  property (value) from the source object.\r\n     *  @param {String} newNotation - The new notation to be set on the new\r\n     *  object for the targeted property value. If not set, `notation` argument\r\n     *  will be used.\r\n     *\r\n     *  @returns {Object} - Returns a new object with the notated property.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Ford\", model: \"Mustang\" } };\r\n     *  const extruded = Notation.create(obj).extrude(\"car.brand\", \"carBrand\");\r\n     *  console.log(obj);\r\n     *  // { car: { model: \"Mustang\" } }\r\n     *  console.log(extruded);\r\n     *  // { carBrand: \"Ford\" }\r\n     */\r\n    extrude(notation, newNotation) {\r\n        const o = {};\r\n        this.moveTo(o, notation, newNotation);\r\n        return o;\r\n    }\r\n\r\n    /**\r\n     *  Alias for `#extrude`\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {String} newNotation -\r\n     *  @returns {Object} -\r\n     */\r\n    moveToNew(notation, newNotation) {\r\n        return this.extrude(notation, newNotation);\r\n    }\r\n\r\n    // --------------------------------\r\n    // STATIC MEMBERS\r\n    // --------------------------------\r\n\r\n    /**\r\n     *  Basically constructs a new `Notation` instance.\r\n     *  @chainable\r\n     *  @param {Object|Array} [source={}] - The source collection to be notated.\r\n     *  @param {Object} [options] - Notation options.\r\n     *      @param {Boolean} [options.strict=false] - Whether to throw when a\r\n     *      notation path does not exist on the source. (Note that `.inspectGet()`\r\n     *      and `.inspectRemove()` methods are exceptions). It's recommended to\r\n     *      set this to `true` and prevent silent failures if you're working\r\n     *      with sensitive data. Regardless of `strict` option, it will always\r\n     *      throw on invalid notation syntax or other crucial failures.\r\n     *\r\n     *  @returns {Notation} - The created instance.\r\n     *\r\n     *  @example\r\n     *  const obj = { car: { brand: \"Dodge\", model: \"Charger\", year: 1970 } };\r\n     *  const notation = Notation.create(obj); // equivalent to new Notation(obj)\r\n     *  notation.get('car.model')   // » \"Charger\"\r\n     *  notation.remove('car.model').set('car.color', 'red').value\r\n     *  // » { car: { brand: \"Dodge\", year: 1970, color: \"red\" } }\r\n     */\r\n    static create(source, options) {\r\n        if (arguments.length === 0) {\r\n            return new Notation({});\r\n        }\r\n        return new Notation(source, options);\r\n    }\r\n\r\n    /**\r\n     *  Checks whether the given notation string is valid. Note that the star\r\n     *  (`*`) (which is a valid character, even if irregular) is NOT treated as\r\n     *  wildcard here. This checks for regular dot-notation, not a glob-notation.\r\n     *  For glob notation validation, use `Notation.Glob.isValid()` method. Same\r\n     *  goes for the negation character/prefix (`!`).\r\n     *\r\n     *  @param {String} notation - The notation string to be checked.\r\n     *  @returns {Boolean} -\r\n     *\r\n     *  @example\r\n     *  Notation.isValid('prop1.prop2.prop3'); // true\r\n     *  Notation.isValid('x'); // true\r\n     *  Notation.isValid('x.arr[0].y'); // true\r\n     *  Notation.isValid('x[\"*\"]'); // true\r\n     *  Notation.isValid('x.*'); // false (this would be valid for Notation#filter() only or Notation.Glob class)\r\n     *  Notation.isValid('@1'); // false (should be \"['@1']\")\r\n     *  Notation.isValid(null); // false\r\n     */\r\n    static isValid(notation) {\r\n        return typeof notation === 'string' && reVALIDATOR.test(notation);\r\n    }\r\n\r\n    /**\r\n     *  Splits the given notation string into its notes (levels).\r\n     *  @param {String} notation  Notation string to be splitted.\r\n     *  @returns {Array} - A string array of notes (levels).\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     */\r\n    static split(notation) {\r\n        if (!Notation.isValid(notation)) {\r\n            throw new NotationError(ERR.NOTATION + `'${notation}'`);\r\n        }\r\n        return notation.match(reMATCHER);\r\n    }\r\n\r\n    /**\r\n     *  Joins the given notes into a notation string.\r\n     *  @param {String} notes  Notes (levels) to be joined.\r\n     *  @returns {String}  Joined notation string.\r\n     */\r\n    static join(notes) {\r\n        return utils.joinNotes(notes);\r\n    }\r\n\r\n    /**\r\n     *  Counts the number of notes/levels in the given notation.\r\n     *  @alias Notation.countLevels\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {Number} - Number of notes.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     */\r\n    static countNotes(notation) {\r\n        return Notation.split(notation).length;\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation.countNotes`.\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @returns {Number} -\r\n     */\r\n    static countLevels(notation) {\r\n        return Notation.countNotes(notation);\r\n    }\r\n\r\n    /**\r\n     *  Gets the first (root) note of the notation string.\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {String} - First note.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.first('first.prop2.last'); // \"first\"\r\n     */\r\n    static first(notation) {\r\n        return Notation.split(notation)[0];\r\n    }\r\n\r\n    /**\r\n     *  Gets the last note of the notation string.\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {String} - Last note.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.last('first.prop2.last'); // \"last\"\r\n     */\r\n    static last(notation) {\r\n        const list = Notation.split(notation);\r\n        return list[list.length - 1];\r\n    }\r\n\r\n    /**\r\n     *  Gets the parent notation (up to but excluding the last note)\r\n     *  from the notation string.\r\n     *  @param {String} notation - The notation string to be processed.\r\n     *  @returns {String} - Parent note if any. Otherwise, `null`.\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  Notation.parent('first.prop2.last'); // \"first.prop2\"\r\n     *  Notation.parent('single'); // null\r\n     */\r\n    static parent(notation) {\r\n        const last = Notation.last(notation);\r\n        return notation.slice(0, -last.length).replace(/\\.$/, '') || null;\r\n    }\r\n\r\n    /**\r\n     *  Iterates through each note/level of the given notation string.\r\n     *  @alias Notation.eachLevel\r\n     *\r\n     *  @param {String} notation - The notation string to be iterated through.\r\n     *  @param {Function} callback - The callback function to be invoked on\r\n     *  each iteration. To break out of the loop, return `false` from within the\r\n     *  callback.\r\n     *  Callback signature: `callback(levelNotation, note, index, list) { ... }`\r\n     *\r\n     *  @returns {void}\r\n     *  @throws {NotationError} - If given notation is invalid.\r\n     *\r\n     *  @example\r\n     *  const notation = 'first.prop2.last';\r\n     *  Notation.eachNote(notation, function (levelNotation, note, index, list) {\r\n     *      console.log(index, note, levelNotation);\r\n     *  });\r\n     *  // 0  \"first\"             \"first\"\r\n     *  // 1  \"first.prop2\"       \"prop2\"\r\n     *  // 2  \"first.prop2.last\"  \"last\"\r\n     */\r\n    static eachNote(notation, callback) {\r\n        const notes = Notation.split(notation);\r\n        const levelNotes = [];\r\n        utils.each(notes, (note, index) => {\r\n            levelNotes.push(note);\r\n            if (callback(Notation.join(levelNotes), note, index, notes) === false) return false;\r\n        }, Notation);\r\n    }\r\n\r\n    /**\r\n     *  Alias of `Notation.eachNote`.\r\n     *  @private\r\n     *  @param {String} notation -\r\n     *  @param {Function} callback -\r\n     *  @returns {void}\r\n     */\r\n    static eachLevel(notation, callback) {\r\n        Notation.eachNote(notation, callback);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n *  Error class specific to `Notation`.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Error}`\r\n */\r\nNotation.Error = NotationError;\r\n\r\n/**\r\n *  Utility for validating, comparing and sorting dot-notation globs.\r\n *  This is internally used by `Notation` class.\r\n *  @private\r\n *\r\n *  @class\r\n *  @see `{@link #Notation.Glob}`\r\n */\r\nNotation.Glob = Glob;\r\n\r\n/**\r\n *  Undocumented\r\n *  @private\r\n */\r\nNotation.utils = utils;\r\n\r\n// --------------------------------\r\n// HELPERS\r\n// --------------------------------\r\n\r\n/**\r\n *  Deep iterates through each note (level) of each item in the given\r\n *  collection.\r\n *  @private\r\n *  @param {Object|Array} collection  A data object or an array, as the source.\r\n *  @param {Function} callback  A function to be executed on each iteration,\r\n *  with the following arguments: `(levelNotation, note, value, collection)`\r\n *  @param {Boolean} [reverseIfArray=false]  Set to `true` to iterate with\r\n *  `eachRight` to prevent shifted indexes when removing items from arrays.\r\n *  @param {Boolean} [byLevel=false]  Indicates whether to iterate notations by\r\n *  each level or by the end value.  For example, if we have a collection of\r\n *  `{a: { b: true } }`, and `byLevel` is set; the callback will be invoked on\r\n *  the following notations: `a`, `a.b`. Otherwise, it will be invoked only on\r\n *  `a.b`.\r\n *  @param {String} [parentNotation]  Storage for parent (previous) notation.\r\n *  @param {Collection} [topSource]  Storage for initial/main collection.\r\n *  @returns {void}\r\n */\r\nfunction _each(collection, callback, reverseIfArray = false, byLevel = false, parentNotation = null, topSource = null) { // eslint-disable-line max-params\r\n    const source = topSource || collection;\r\n    // if (!utils.isCollection(collection)) throw ... // no need\r\n    utils.eachItem(collection, (value, keyOrIndex) => {\r\n        const note = typeof keyOrIndex === 'number'\r\n            ? `[${keyOrIndex}]`\r\n            : keyOrIndex;\r\n        const currentNotation = Notation.join([parentNotation, note]);\r\n        const isCollection = utils.isCollection(value);\r\n        // if it's not a collection we'll execute the callback. if it's a\r\n        // collection but byLevel is set, we'll also execute the callback.\r\n        if (!isCollection || byLevel) {\r\n            if (callback(currentNotation, note, value, source) === false) return false;\r\n        }\r\n        // deep iterating if collection\r\n        if (isCollection) _each(value, callback, reverseIfArray, byLevel, currentNotation, source);\r\n    }, null, reverseIfArray);\r\n}\r\n\r\n// --------------------------------\r\n// EXPORT\r\n// --------------------------------\r\n\r\nexport { Notation };\r\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","setProto","setPrototypeOf","NotationError","_Error","_inherits","_super","_createSuper","_this","message","arguments","length","undefined","_classCallCheck","_assertThisInitialized","writable","Error","captureStackTrace","stack","_wrapNativeSuper","objProto","symValueOf","valueOf","VAR","ARRAY_NOTE","OBJECT_BRACKETS","NON_NEG_WILDCARD_TRAIL","_reFlags","utils","re","ARRAY_GLOB_NOTE","WILDCARD","WILDCARDS","NEGATE_ALL","type","toString","match","toLowerCase","isCollection","t","isset","ensureArray","hasOwn","collection","keyOrIndex","_collectionType","cloneDeep","Date","flags","exec","copy","constructor","source","lastIndex","map","keys","forEach","k","each","array","callback","thisArg","len","index","apply","eachRight","eachProp","object","eachItem","reverseIfArray","pregQuote","str","String","replace","stringOrArrayOf","hasSingleItemOf","arr","itemValue","removeTrailingWildcards","glob","normalizeNote","note","test","m","parseInt","concat","joinNotes","notes","current","i","next","join","getNewNotation","newNotation","notation","newN","errMsg","trim","reMATCHER","reVALIDATOR","RegExp","ERR_INVALID","Glob","ins","_inspect","split","absGlob","_","_objectSpread","parent","regexp","isNegated","toRegExp","slice","last","Notation","isValid","_covers","restrictive","_intersect","g","indexOf","globA","globB","a","b","notesA","notesB","covers","fn","_matchesNote","_coversNote","bang","Math","max","notesI","push","isArrayGlob","normalize","aIdxCompare","_compareArrayItemGlobs","wildCountA","wildCountB","globList","sort","compare","original","list","_negFirstSort","_negLastSort","negateAll","normalized","ignored","intersections","checkAddIntersection","gA","gB","inter","hasInverted","indexA","duplicate","hasExactNeg","negCoversPos","negCoveredByPos","negCoveredByNeg","posCoversPos","posCoveredByNeg","posCoveredByPos","indexB","JSON","stringify","splice","_isReverseOf","coversB","coveredByB","keepNeg","keepPos","globsListA","globsListB","union","notCovered","hasExact","negCoversNeg","posCoversNeg","keep","globsA","globsB","_compareUnion","listA","listB","bIsArr","_idxVal","_compArrIdx","lastA","lastB","reANote","_rx","negA","negB","ERR","DEFAULT_OPTS","freeze","strict","preserveIndices","options","_source","_isArray","_options","set","_each","level","eachNote","levelNotation","create","merge","expand","result","has","lastNoteNormalized","lastNote","parentIsArray","parentNotation","inspectGet","defaultValue","msg","mode","currentIsLast","nCurrentNote","nNextNote","nextIsArrayNote","insertErrMsg","notationsObject","overwrite","notations","_this2","inspectRemove","_this3","globs","empty","filtered","cloned","firstIsWildcard","shift","globNotation","emptyValue","eType","levels","errGlobIntegrity","insRemove","vType","isValSet","setMode","insGet","originalNotation","levelLen","remove","destination","target","moveTo","rename","copyTo","extract","extrude","countNotes","levelNotes","byLevel","currentNotation"],"sourceRoot":""}